{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#title-and-path-matching-of-rules","title":"Title and path matching of rules","text":"<p>Detect titles of Philippine statutory text from given text input.</p> <p>Upon detection, generate a possible path from which to extract the content of a detected rule.</p> <p>This presumes existence of a local path to a separate library where the contents of the rule can be extracted from.</p> Python<pre><code># use sample text for demo\n&gt;&gt;&gt; text = \"\"\"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\"\"\n# get first matching rule with helper to extract path\nfrom statute_patterns import extract_rule\n&gt;&gt;&gt; rule_obj = extract_rule(text)\n&gt;&gt;&gt; rule_obj\nRule(cat='ra', id='386')\n# get all rules\n&gt;&gt;&gt; from statute_patterns import extract_rules\n&gt;&gt;&gt; extract_rules(text)\n[\nRule(cat='ra', id='386'),\nRule(cat='ra', id='386'),\nRule(cat='spain', id='civil')\n]\n# get unique rules with counts\n&gt;&gt;&gt; from statute_patterns import count_rules\n&gt;&gt;&gt; count_rules(text):\n[\n{'cat': 'ra', 'id': '386', 'mentions': 2},\n{'cat': 'spain', 'id': 'civil', 'mentions': 1}\n]\n</code></pre>"},{"location":"#loading-files-from-rules","title":"Loading files from rules","text":"<p>Each rule corresponds to a possible set of folders in a local directory <code>/statutes</code>.</p> <p>Each rule belongs to a StatuteSerialCategory. The present StatuteSerialCategory is an Enum with the following members. The value of each member is the path to such category.</p> Python<pre><code>&gt;&gt;&gt;StatuteSerialCategory\n&lt;enum 'StatuteSerialCategory'&gt;\n&gt;&gt;&gt;StatuteSerialCategory._member_map_\n{\n'RepublicAct': &lt;StatuteSerialCategory.RepublicAct: 'ra'&gt;,\n'CommonwealthAct': &lt;StatuteSerialCategory.CommonwealthAct: 'ca'&gt;,\n'Act': &lt;StatuteSerialCategory.Act: 'act'&gt;,\n'Constitution': &lt;StatuteSerialCategory.Constitution: 'const'&gt;,\n'Spain': &lt;StatuteSerialCategory.Spain: 'spain'&gt;,\n'BatasPambansa': &lt;StatuteSerialCategory.BatasPambansa: 'bp'&gt;,\n'PresidentialDecree': &lt;StatuteSerialCategory.PresidentialDecree: 'pd'&gt;,\n'ExecutiveOrder': &lt;StatuteSerialCategory.ExecutiveOrder: 'eo'&gt;,\n'LetterOfInstruction': &lt;StatuteSerialCategory.LetterOfInstruction: 'loi'&gt;,\n'VetoMessage': &lt;StatuteSerialCategory.VetoMessage: 'veto'&gt;,\n'RulesOfCourt': &lt;StatuteSerialCategory.RulesOfCourt: 'roc'&gt;,\n'BarMatter': &lt;StatuteSerialCategory.BarMatter: 'rule_bm'&gt;,\n'AdministrativeMatter': &lt;StatuteSerialCategory.AdministrativeMatter: 'rule_am'&gt;,\n'ResolutionEnBanc': &lt;StatuteSerialCategory.ResolutionEnBanc: 'rule_reso'&gt;,\n'CircularOCA': &lt;StatuteSerialCategory.CircularOCA: 'oca_cir'&gt;,\n'CircularSC': &lt;StatuteSerialCategory.CircularSC: 'sc_cir'&gt;\n}\n</code></pre> <p>So to point to the Civil Code of the Philippines, this would be represented by the following path <code>statutes/ra/386</code> where ra is the StatuteSerialCategory and 386 is the serial id.</p> <p>Knowing the path to a rule, we can extract the rule's contents.</p> Python<pre><code>&gt;&gt;&gt; rule_obj # example from above\nRule(cat='ra', id='386')\n&gt;&gt;&gt; list(rule_obj.extract_folders(&lt;path/to/statutes&gt;))\n[PosixPath('.../statutes/ra/386')]\n</code></pre> <p>There can be more than one path since in exceptional cases, the combination of category + serial id does not yield a unique rule.</p> <p>We can extract the details of the rule with the <code>StatuteDetails.from_rule()</code> also accessible via <code>Rule.get_details()</code>:</p> Python<pre><code>&gt;&gt;&gt;from statute_patterns import StatuteDetails\n&gt;&gt;&gt;StatuteDetails.from_rule(rule_obj, &lt;path/to/statutes&gt;) # or rule_obj.get_details(&lt;path/to/details&gt;)\nStatuteDetails(\ncreated=1665225124.0644598,\nmodified=1665225124.0644598,\nrule=Rule(cat='ra', id='386'),\ntitle='Republic Act No. 386',\ndescription='An Act to Ordain and Institute the Civil Code of the Philippines',\nid='ra-386-june-18-1949',\nemails=['maria@abcxyz.law', 'fernando@abcxyz.law'],\ndate=datetime.date(1949, 6, 18),\nvariant=1,\nunits=[\n{\n'item': 'Container 1',\n'caption': 'Preliminary Title',\n'units': [\n{\n'item': 'Chapter 1',\n'caption': 'Effect and Application of Laws',\n'units': [\n{\n'item': 'Article 1',\n'content': 'This Act shall be known as the \"Civil Code of the Philippines.\" (n)\\n'\n},\n{\n'item': 'Article 2',\n'content': 'Laws shall take effect after fifteen days following the completion of their publication either in the Official Gazette or in a newspaper of general circulation in the Philippines, unless it is otherwise provided. (1a)\\n'\n},\n...\n]\n},\n...\n]\n},\n...\n],\ntitles=[\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='alias',\ntext='New Civil Code'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='alias',\ntext='Civil Code of 1950'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='official',\ntext='An Act to Ordain and Institute the Civil Code of the Philippines'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='serial',\ntext='Republic Act No. 386'\n)\n]\n)\n</code></pre>"},{"location":"details/","title":"Statute Details","text":"<p>         Bases: <code>BaseModel</code></p> <p>Based on a <code>Rule</code> object, obtain details loaded from files found in a Rule's proper path; the <code>description</code> field is relevant as the source material for the statute's serial title.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>class StatuteDetails(BaseModel):\n\"\"\"\n    Based on a `Rule` object, obtain details loaded from files found in a\n    Rule's proper path; the `description` field is relevant as the source\n    material for the statute's serial title.\"\"\"\ncreated: float\nmodified: float\nrule: Rule\ntitle: str\ndescription: str\nid: str\nemails: list[EmailStr]\ndate: datetime.date\nvariant: int\ntitles: list[StatuteTitle]\nunits: list[dict]\n@classmethod\ndef slug_id(cls, p: Path, dt: str, v: int | None):\n\"\"\"Use the path's parameters with the date and variant, to\n        create a slug that can serve as the url / primary key of the\n        statute.\"\"\"\n_temp = [p.parent.parent.stem, p.parent.stem, dt]\nif v:\n_temp.append(str(v))\nreturn slugify(\" \".join(_temp))\n@classmethod\ndef from_rule(cls, rule: Rule, base_path: Path = STATUTE_PATH):\n\"\"\"From a constructed rule (see `Rule.from_path()`), get the\n        details of said rule.  Limitation: the category and identifier must\n        be unique.\"\"\"\nif not base_path.exists():\nraise Exception(f\"Could not get proper {base_path=}.\")\nif not rule.serial_title:\nraise Exception(\"No serial title created.\")\n_file = None\nif folder := rule.get_path(base_path):\n_file = folder / DETAILS_FILE\nif not _file or not _file.exists():\nraise Exception(f\"No _file found from {folder=} {base_path=}.\")\nd = yaml.safe_load(_file.read_bytes())\ndt, ofc_title, v = d.get(\"date\"), d.get(\"law_title\"), d.get(\"variant\")\nif not all([ofc_title, dt]):\nraise Exception(f\"Fail on: {dt=}, {ofc_title=}, {v=}\")\nunits = set_units(ofc_title, rule.units_path(_file.parent))\nidx = cls.slug_id(_file, dt, v)\ntitles = StatuteTitle.generate(\npk=idx,\nofficial=ofc_title,\nserial=rule.serial_title,\nshort=get_short(units),\naliases=d.get(\"aliases\"),\n)\nreturn cls(\ncreated=_file.stat().st_ctime,\nmodified=_file.stat().st_mtime,\nrule=rule,\nid=idx,\ntitle=rule.serial_title,\ndescription=ofc_title,\nemails=d.get(\"emails\", [\"bot@lawsql.com\"]),  # default to generic\ndate=parse(d[\"date\"]).date(),\nvariant=v or 1,  # default to 1\nunits=units,\ntitles=list(titles),\n)\n</code></pre>"},{"location":"details/#statute_patterns.components.details.StatuteDetails-functions","title":"Functions","text":""},{"location":"details/#statute_patterns.components.details.StatuteDetails.from_rule","title":"<code>from_rule(rule, base_path=STATUTE_PATH)</code>  <code>classmethod</code>","text":"<p>From a constructed rule (see <code>Rule.from_path()</code>), get the details of said rule.  Limitation: the category and identifier must be unique.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>@classmethod\ndef from_rule(cls, rule: Rule, base_path: Path = STATUTE_PATH):\n\"\"\"From a constructed rule (see `Rule.from_path()`), get the\n    details of said rule.  Limitation: the category and identifier must\n    be unique.\"\"\"\nif not base_path.exists():\nraise Exception(f\"Could not get proper {base_path=}.\")\nif not rule.serial_title:\nraise Exception(\"No serial title created.\")\n_file = None\nif folder := rule.get_path(base_path):\n_file = folder / DETAILS_FILE\nif not _file or not _file.exists():\nraise Exception(f\"No _file found from {folder=} {base_path=}.\")\nd = yaml.safe_load(_file.read_bytes())\ndt, ofc_title, v = d.get(\"date\"), d.get(\"law_title\"), d.get(\"variant\")\nif not all([ofc_title, dt]):\nraise Exception(f\"Fail on: {dt=}, {ofc_title=}, {v=}\")\nunits = set_units(ofc_title, rule.units_path(_file.parent))\nidx = cls.slug_id(_file, dt, v)\ntitles = StatuteTitle.generate(\npk=idx,\nofficial=ofc_title,\nserial=rule.serial_title,\nshort=get_short(units),\naliases=d.get(\"aliases\"),\n)\nreturn cls(\ncreated=_file.stat().st_ctime,\nmodified=_file.stat().st_mtime,\nrule=rule,\nid=idx,\ntitle=rule.serial_title,\ndescription=ofc_title,\nemails=d.get(\"emails\", [\"bot@lawsql.com\"]),  # default to generic\ndate=parse(d[\"date\"]).date(),\nvariant=v or 1,  # default to 1\nunits=units,\ntitles=list(titles),\n)\n</code></pre>"},{"location":"details/#statute_patterns.components.details.StatuteDetails.slug_id","title":"<code>slug_id(p, dt, v)</code>  <code>classmethod</code>","text":"<p>Use the path's parameters with the date and variant, to create a slug that can serve as the url / primary key of the statute.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>@classmethod\ndef slug_id(cls, p: Path, dt: str, v: int | None):\n\"\"\"Use the path's parameters with the date and variant, to\n    create a slug that can serve as the url / primary key of the\n    statute.\"\"\"\n_temp = [p.parent.parent.stem, p.parent.stem, dt]\nif v:\n_temp.append(str(v))\nreturn slugify(\" \".join(_temp))\n</code></pre>"},{"location":"extra/","title":"Extra Functions","text":""},{"location":"extra/#extract-short-title","title":"Extract Short Title","text":"Source code in <code>statute_patterns/components/short.py</code> Python<pre><code>def get_short(units: list[dict]) -&gt; str | None:\ntry:\nreturn next(find_title(units))\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"extract/","title":"Extraction","text":""},{"location":"extract/#extract-rules","title":"Extract Rules","text":"<p>If text contains matching serialized (e.g. Republic Act No. 386) and named rules ('the Civil Code of the Philippines'), produce both.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; list(extract_rules(text)) # get all rules\n[\n    Rule(cat='ra', id='386'),\n    Rule(cat='ra', id='386'),\n    Rule(cat='spain', id='civil')\n]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for statute patterns.</p> required <p>Yields:</p> Type Description <code>Iterator[Rule]</code> <p>Iterator[Rule]: Serialized Rules and Named Rule patterns</p> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def extract_rules(text: str) -&gt; Iterator[Rule]:\n\"\"\"If text contains matching serialized (e.g. Republic Act No. 386)\n    and named rules ('the Civil Code of the Philippines'), produce both.\n    Examples:\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; list(extract_rules(text)) # get all rules\n        [\n            Rule(cat='ra', id='386'),\n            Rule(cat='ra', id='386'),\n            Rule(cat='spain', id='civil')\n        ]\n    Args:\n        text (str): Text to search for statute patterns.\n    Yields:\n        Iterator[Rule]: Serialized Rules and Named Rule patterns\n    \"\"\"\nyield from SerializedRules.extract_rules(text)\nyield from NamedRules.extract_rules(text)\n</code></pre>"},{"location":"extract/#extract-rule","title":"Extract Rule","text":"<p>Thin wrapper over <code>extract_rules()</code>. If text contains a matching rule, get the first rule found.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; extract_rule(text)  # get the first matching rule\nRule(cat='ra', id='386')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for statute patterns.</p> required <p>Returns:</p> Type Description <code>Rule | None</code> <p>Rule | None: The first serialized rule or named rule found, if it exists</p> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def extract_rule(text: str) -&gt; Rule | None:\n\"\"\"Thin wrapper over `extract_rules()`. If text contains a\n    matching rule, get the first rule found.\n    Examples:\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; extract_rule(text)  # get the first matching rule\n        Rule(cat='ra', id='386')\n    Args:\n        text (str): Text to search for statute patterns.\n    Returns:\n        Rule | None: The first serialized rule or named rule found, if it exists\n    \"\"\"\ntry:\nreturn next(extract_rules(text))\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"extract/#count-rules","title":"Count Rules","text":"<p>Based on results from <code>extract_rules(text)</code>, get the count of each unique rule found.</p> <p>text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\" list(count_rules(text)): # get unique rules with counts [     {'cat': 'ra', 'id': '386', 'mentions': 2},     {'cat': 'spain', 'id': 'civil', 'mentions': 1} ]</p> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def count_rules(text: str) -&gt; Iterator[dict]:\n\"\"\"Based on results from `extract_rules(text)`, get the count of each unique rule found.\n    &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n    &gt;&gt;&gt; list(count_rules(text)): # get unique rules with counts\n    [\n        {'cat': 'ra', 'id': '386', 'mentions': 2},\n        {'cat': 'spain', 'id': 'civil', 'mentions': 1}\n    ]\n    \"\"\"\nfor k, v in Counter(extract_rules(text)).items():\nyield k.dict() | {\"mentions\": v}\n</code></pre>"},{"location":"named/","title":"Named Statutes","text":""},{"location":"named/#named-pattern","title":"Named Pattern","text":"<p>         Bases: <code>BasePattern</code></p> <p>A<code>Rule</code> can be extracted from a <code>NamedPattern</code></p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class NamedPattern(BasePattern):\n\"\"\"A`Rule` can be extracted from a `NamedPattern`\"\"\"\nname: str\nregex_base: str\nrule: Rule\n@property\ndef regex(self) -&gt; str:\nreturn stx(rf\"(?P&lt;{self.group_name}&gt;{self.regex_base})\")\n@property\ndef group_name(self) -&gt; str:\ntexts = \" \".join([self.rule.cat, self.rule.id])\nreturn slugify(texts, separator=\"_\", lowercase=True)\n</code></pre>"},{"location":"named/#named-statute-collection","title":"Named Statute Collection","text":"<p>         Bases: <code>BaseCollection</code></p> <p>Each named legal title, not falling under the SerialNames Patterns, will also have its own manually crafted regex string. Examples include 'the Spanish Civil Code' or the '1987 Constitution' or the 'Code of Professional Responsibility'.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class NamedPatternCollection(BaseCollection):\n\"\"\"Each named legal title, not falling under the SerialNames Patterns, will also have its own manually crafted regex string. Examples include 'the Spanish Civil Code' or the '1987 Constitution' or the 'Code of Professional Responsibility'.\"\"\"\ncollection: list[NamedPattern]\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\nfor m in self.pattern.finditer(text):\nfor named in self.collection:\nif m.lastgroup == named.group_name:\nyield named.rule\n</code></pre>"},{"location":"rule/","title":"Abstract Rule","text":""},{"location":"rule/#rule","title":"Rule","text":"<p>         Bases: <code>BaseModel</code></p> <p>Created primarily via <code>NamedPatternCollection</code> or a <code>SerialPatternCollection</code>, a <code>Rule</code> has many use cases:</p> <ol> <li>Prior validation by <code>NamedPattern</code> or a <code>SerialPattern</code> regex strings with Pydantic validation.</li> <li>Ensure a consistent path to an intended local directory via a uniform <code>StatuteSerialCategory</code> folder (<code>cat</code>) and a target serialized statute (<code>id</code>).</li> <li>Extract the details and units files from the path designated.</li> <li>Generate a serial title based on the <code>StatuteSerialCategory.serialize()</code> function.</li> <li>Be an exceptional Pydantic BaseModel which is countable through the collection.Counter built-in.</li> </ol> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class Rule(BaseModel):\n\"\"\"Created primarily via `NamedPatternCollection` or\n    a `SerialPatternCollection`, a `Rule` has many use cases:\n    1. Prior validation by `NamedPattern` or a `SerialPattern` regex strings with Pydantic validation.\n    2. Ensure a consistent path to an intended local directory via a uniform `StatuteSerialCategory` folder (`cat`) and a target serialized statute (`id`).\n    3. Extract the details and units files from the path designated.\n    4. Generate a serial title based on the `StatuteSerialCategory.serialize()` function.\n    5. Be an exceptional Pydantic BaseModel which is countable through the collection.Counter built-in.\n    \"\"\"\ncat: StatuteSerialCategory = Field(\n...,\ntitle=\"Statute Category\",\ndescription=\"Classification under the limited StatuteSerialCategory taxonomy.\",\n)\nid: constr(to_lower=True) = Field(  # type: ignore\n...,\ntitle=\"Serial Identifier\",\ndescription=\"Limited inclusion of identifiers, e.g. only a subset of Executive Orders, Letters of Instruction, Spanish Codes will be permitted.\",\n)\nclass Config:\nuse_enum_values = True\ndef __hash__(self):\n\"\"\"Pydantic models are not hashable by default. The implementation in this case becomes useful for the built-in collections.Counter (used in statute_patterns.count_rules). See https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964.\"\"\"\nreturn hash((type(self),) + tuple(self.__dict__.values()))\n@validator(\"cat\", pre=True)\ndef category_in_lower_case(cls, v):\nreturn StatuteSerialCategory(v.lower())\n@validator(\"id\", pre=True)\ndef serial_id_lower(cls, v):\nreturn v.lower()\n@classmethod\ndef get_details(cls, details_path: Path):\n\"\"\"Assumes a properly structured path with three path\n        parents from details.yaml, e.g. path to `/statutes/ra/386/details.yaml`\n        means 3 parents from the same would be /statutes. Will\n        create the rule based on the details path and pull data from other\n        related paths to generate the details of the rule.\"\"\"\nfrom .details import StatuteDetails\nif rule := cls.from_path(details_path):\nstatute_path = details_path.parent.parent.parent\nreturn StatuteDetails.from_rule(rule, statute_path)\nreturn None\n@classmethod\ndef from_path(cls, details_path: Path):\n\"\"\"Construct rule from a properly structured statute's `details.yaml` file.\"\"\"\ndir = details_path.parent\ncat = dir.parent.stem\nidx = dir.stem\nif details_path.name == DETAILS_FILE:\nreturn cls(cat=StatuteSerialCategory(cat), id=idx)\nreturn None\n@property\ndef serial_title(self):\nreturn StatuteSerialCategory(self.cat).serialize(self.id)\ndef get_path(self, base_path: Path = STATUTE_PATH) -&gt; Path | None:\n\"\"\"For most cases, there only be one path to path/to/statutes/ra/386 where:\n        1. path/to/statutes = base_path\n        2. 'ra' is the category\n        3. '386' is the id.\n        \"\"\"\ntarget = base_path / self.cat / self.id\nif target.exists():\nreturn target\nreturn None\ndef get_paths(self, base_path: Path = STATUTE_PATH) -&gt; list[Path]:\n\"\"\"The serial id isn't enough in complex statutes.\n        To simplify, imagine Statute A, B and C have the same\n        category and identifier. But refer to different documents.\n        Because of this dilemma, we introduce a digit in the creation of statute\n        folders referring to more than one variant of the intended document.\n        So in the case of `/statutes/rule_am/`, let's consider `00-5-03-sc`.\n        This should be valid statute under `self.get_path()`.\n        However, since there exists 2 variants, we need to rename the original\n        folder to contemplate 2 distinct documents:\n        1. statutes/rule_am/00-5-03-sc-1\n        2. statutes/rule_am/00-5-03-sc-2\n        Both folders will be retrieved using the plural form of\n        the function `self.get_paths()`\n        \"\"\"\ntargets = []\ntarget = base_path / self.cat\npaths = target.glob(f\"{self.id}-*/{DETAILS_FILE}\")\nfor variant_path in paths:\nif variant_path.exists():\ntargets.append(variant_path.parent)\nreturn targets\ndef extract_folders(\nself, base_path: Path = STATUTE_PATH\n) -&gt; Iterator[Path]:\n\"\"\"Using the `category` and `id` of the object,\n        get the possible folder paths.\"\"\"\nif folder := self.get_path(base_path):\nyield folder\nelse:\nif folders := self.get_paths(base_path):\nyield from folders\ndef units_path(self, statute_folder: Path) -&gt; Path | None:\n\"\"\"There are two kinds of unit files: the preferred / customized\n        variant and the one scraped (the default in the absence of a preferred\n        variant).\"\"\"\npreferred = statute_folder / f\"{self.cat}{self.id}.yaml\"\nif preferred.exists():\nreturn preferred\ndefault = statute_folder / \"units.yaml\"\nif default.exists():\nreturn default\nreturn None\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.Rule-functions","title":"Functions","text":""},{"location":"rule/#statute_patterns.components.rule.Rule.__hash__","title":"<code>__hash__()</code>","text":"<p>Pydantic models are not hashable by default. The implementation in this case becomes useful for the built-in collections.Counter (used in statute_patterns.count_rules). See https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def __hash__(self):\n\"\"\"Pydantic models are not hashable by default. The implementation in this case becomes useful for the built-in collections.Counter (used in statute_patterns.count_rules). See https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964.\"\"\"\nreturn hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.Rule.extract_folders","title":"<code>extract_folders(base_path=STATUTE_PATH)</code>","text":"<p>Using the <code>category</code> and <code>id</code> of the object, get the possible folder paths.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def extract_folders(\nself, base_path: Path = STATUTE_PATH\n) -&gt; Iterator[Path]:\n\"\"\"Using the `category` and `id` of the object,\n    get the possible folder paths.\"\"\"\nif folder := self.get_path(base_path):\nyield folder\nelse:\nif folders := self.get_paths(base_path):\nyield from folders\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.Rule.from_path","title":"<code>from_path(details_path)</code>  <code>classmethod</code>","text":"<p>Construct rule from a properly structured statute's <code>details.yaml</code> file.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>@classmethod\ndef from_path(cls, details_path: Path):\n\"\"\"Construct rule from a properly structured statute's `details.yaml` file.\"\"\"\ndir = details_path.parent\ncat = dir.parent.stem\nidx = dir.stem\nif details_path.name == DETAILS_FILE:\nreturn cls(cat=StatuteSerialCategory(cat), id=idx)\nreturn None\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.Rule.get_details","title":"<code>get_details(details_path)</code>  <code>classmethod</code>","text":"<p>Assumes a properly structured path with three path parents from details.yaml, e.g. path to <code>/statutes/ra/386/details.yaml</code> means 3 parents from the same would be /statutes. Will create the rule based on the details path and pull data from other related paths to generate the details of the rule.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>@classmethod\ndef get_details(cls, details_path: Path):\n\"\"\"Assumes a properly structured path with three path\n    parents from details.yaml, e.g. path to `/statutes/ra/386/details.yaml`\n    means 3 parents from the same would be /statutes. Will\n    create the rule based on the details path and pull data from other\n    related paths to generate the details of the rule.\"\"\"\nfrom .details import StatuteDetails\nif rule := cls.from_path(details_path):\nstatute_path = details_path.parent.parent.parent\nreturn StatuteDetails.from_rule(rule, statute_path)\nreturn None\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.Rule.get_path","title":"<code>get_path(base_path=STATUTE_PATH)</code>","text":"<p>For most cases, there only be one path to path/to/statutes/ra/386 where:</p> <ol> <li>path/to/statutes = base_path</li> <li>'ra' is the category</li> <li>'386' is the id.</li> </ol> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def get_path(self, base_path: Path = STATUTE_PATH) -&gt; Path | None:\n\"\"\"For most cases, there only be one path to path/to/statutes/ra/386 where:\n    1. path/to/statutes = base_path\n    2. 'ra' is the category\n    3. '386' is the id.\n    \"\"\"\ntarget = base_path / self.cat / self.id\nif target.exists():\nreturn target\nreturn None\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.Rule.get_paths","title":"<code>get_paths(base_path=STATUTE_PATH)</code>","text":"<p>The serial id isn't enough in complex statutes.</p> <p>To simplify, imagine Statute A, B and C have the same category and identifier. But refer to different documents.</p> <p>Because of this dilemma, we introduce a digit in the creation of statute folders referring to more than one variant of the intended document.</p> <p>So in the case of <code>/statutes/rule_am/</code>, let's consider <code>00-5-03-sc</code>. This should be valid statute under <code>self.get_path()</code>.</p> <p>However, since there exists 2 variants, we need to rename the original folder to contemplate 2 distinct documents:</p> <ol> <li>statutes/rule_am/00-5-03-sc-1</li> <li>statutes/rule_am/00-5-03-sc-2</li> </ol> <p>Both folders will be retrieved using the plural form of the function <code>self.get_paths()</code></p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def get_paths(self, base_path: Path = STATUTE_PATH) -&gt; list[Path]:\n\"\"\"The serial id isn't enough in complex statutes.\n    To simplify, imagine Statute A, B and C have the same\n    category and identifier. But refer to different documents.\n    Because of this dilemma, we introduce a digit in the creation of statute\n    folders referring to more than one variant of the intended document.\n    So in the case of `/statutes/rule_am/`, let's consider `00-5-03-sc`.\n    This should be valid statute under `self.get_path()`.\n    However, since there exists 2 variants, we need to rename the original\n    folder to contemplate 2 distinct documents:\n    1. statutes/rule_am/00-5-03-sc-1\n    2. statutes/rule_am/00-5-03-sc-2\n    Both folders will be retrieved using the plural form of\n    the function `self.get_paths()`\n    \"\"\"\ntargets = []\ntarget = base_path / self.cat\npaths = target.glob(f\"{self.id}-*/{DETAILS_FILE}\")\nfor variant_path in paths:\nif variant_path.exists():\ntargets.append(variant_path.parent)\nreturn targets\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.Rule.units_path","title":"<code>units_path(statute_folder)</code>","text":"<p>There are two kinds of unit files: the preferred / customized variant and the one scraped (the default in the absence of a preferred variant).</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def units_path(self, statute_folder: Path) -&gt; Path | None:\n\"\"\"There are two kinds of unit files: the preferred / customized\n    variant and the one scraped (the default in the absence of a preferred\n    variant).\"\"\"\npreferred = statute_folder / f\"{self.cat}{self.id}.yaml\"\nif preferred.exists():\nreturn preferred\ndefault = statute_folder / \"units.yaml\"\nif default.exists():\nreturn default\nreturn None\n</code></pre>"},{"location":"rule/#basepattern","title":"BasePattern","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BasePattern(BaseModel, abc.ABC):\nmatches: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should_ match regex property.\",\n)\nexcludes: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should not_ match regex property.\",\n)\nclass Config:\nuse_enum_values = True\ndef __init__(self, **kwargs):\nsuper().__init__(**kwargs)\nself.validate_matches()\nself.validate_excludes()\n@property\n@abc.abstractmethod\ndef regex(self) -&gt; str:\n\"\"\"Combines the group_name with the desired regex string.\"\"\"\nraise NotImplementedError(\n\"Base regex to be later combined with other rules regex strings.\"\n)\n@property\n@abc.abstractmethod\ndef group_name(self) -&gt; str:\n\"\"\"Added to regex string to identify the `match.lastgroup`\"\"\"\nraise NotImplementedError(\"Used to identify `regex` capture group.\")\n@property\ndef pattern(self) -&gt; Pattern:\n\"\"\"Enables use of a unique Pattern object per rule pattern created,\n        regardless of it being a SerialPattern or a NamedPattern.\"\"\"\nreturn re.compile(self.regex, re.X)\ndef validate_matches(self) -&gt; None:\nfor example_text in self.matches:\nif not self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Missing match but intended to be included: {example_text}\"\n)\ndef validate_excludes(self) -&gt; None:\nfor example_text in self.excludes:\nif self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Match found even if intended to be excluded: {example_text}.\"\n)\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.BasePattern-attributes","title":"Attributes","text":""},{"location":"rule/#statute_patterns.components.rule.BasePattern.group_name","title":"<code>group_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Added to regex string to identify the <code>match.lastgroup</code></p>"},{"location":"rule/#statute_patterns.components.rule.BasePattern.pattern","title":"<code>pattern: Pattern</code>  <code>property</code>","text":"<p>Enables use of a unique Pattern object per rule pattern created, regardless of it being a SerialPattern or a NamedPattern.</p>"},{"location":"rule/#statute_patterns.components.rule.BasePattern.regex","title":"<code>regex: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Combines the group_name with the desired regex string.</p>"},{"location":"rule/#basecollection","title":"BaseCollection","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> <p>Whether a collection of Named or Serial patterns are instantiated, a <code>combined_regex</code> property and a <code>pattern</code> propery will be automatically created based on the collection of objects declared on instantiation of the class.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BaseCollection(BaseModel, abc.ABC):\n\"\"\"Whether a collection of Named or Serial patterns are instantiated,\n    a `combined_regex` property and a `pattern` propery will be automatically\n    created based on the collection of objects declared on instantiation\n    of the class.\"\"\"\ncollection: list = NotImplemented\n@abc.abstractmethod\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\nraise NotImplementedError(\"Need ability to fetch Rule objects.\")\n@property\ndef combined_regex(self) -&gt; str:\n\"\"\"Combine the different items in the collection\n        (having .regex attribute) to form a single regex string.\"\"\"\nreturn \"|\".join([r.regex for r in self.collection])\n@property\ndef pattern(self) -&gt; Pattern:\nreturn re.compile(self.combined_regex, re.X)\n</code></pre>"},{"location":"rule/#statute_patterns.components.rule.BaseCollection-attributes","title":"Attributes","text":""},{"location":"rule/#statute_patterns.components.rule.BaseCollection.combined_regex","title":"<code>combined_regex: str</code>  <code>property</code>","text":"<p>Combine the different items in the collection (having .regex attribute) to form a single regex string.</p>"},{"location":"serial/","title":"Serialized Statutes","text":""},{"location":"serial/#statute-serial-category","title":"Statute Serial Category","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>This is a non-exhaustive taxonomy of Philippine legal rules for the purpose of enumerating fixed values.</p> <p>Both parts of the member declaration have meaning.</p> <p>The name of each statute category can be \"uncamel\"-ized to produce a serial title of the member for most of the members enumerated.</p> <p>The value of each statute category serves 2 purposes:</p> <ol> <li>it refers to the folder to source raw .yaml files for the creation of the Statute object for the database; and</li> <li>it refers to the category as it appears in the database table.</li> </ol> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>class StatuteSerialCategory(str, Enum):\n\"\"\"\n    This is a non-exhaustive taxonomy of Philippine legal rules for the purpose of enumerating fixed values.\n    Both parts of the member declaration have meaning.\n    The **name** of each statute category can be \"uncamel\"-ized to produce a serial title of the member for _most_ of the members enumerated.\n    The **value** of each statute category serves 2 purposes:\n    1. it refers to the folder to source raw .yaml files for the creation of the Statute object for the database; and\n    2. it refers to the category as it appears in the database table.\n    \"\"\"\nRepublicAct = \"ra\"\nCommonwealthAct = \"ca\"\nAct = \"act\"\nConstitution = \"const\"\nSpain = \"spain\"\nBatasPambansa = \"bp\"\nPresidentialDecree = \"pd\"\nExecutiveOrder = \"eo\"\nLetterOfInstruction = \"loi\"\nVetoMessage = \"veto\"\nRulesOfCourt = \"roc\"\nBarMatter = \"rule_bm\"\nAdministrativeMatter = \"rule_am\"\nResolutionEnBanc = \"rule_reso\"\nCircularOCA = \"oca_cir\"\nCircularSC = \"sc_cir\"\ndef serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n        Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n        1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n        2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n        \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"serial/#statute_patterns.components.category.StatuteSerialCategory-functions","title":"Functions","text":""},{"location":"serial/#statute_patterns.components.category.StatuteSerialCategory.serialize","title":"<code>serialize(idx)</code>","text":"<p>Given a member item and a valid serialized identifier, create a serial title.</p> <p>Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.</p> <ol> <li><code>pd</code> + <code>570-a</code> = <code>Presidential Decree No. 570-A</code></li> <li><code>rule_am</code> + <code>03-06-13-sc</code> = <code>Administrative Matter No. 03-06-13-SC</code></li> </ol> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>def serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n    Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n    1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n    2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n    \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"serial/#serial-pattern","title":"Serial Pattern","text":"<p>         Bases: <code>BasePattern</code></p> <p>A<code>Rule</code> can be extracted from a <code>SerialPattern</code>. The word \"serial\" is employed because the documents representing rules are numbered consecutively.</p> <p>Each serial pattern refers to a specific category, e.g. <code>RA</code>, <code>CA</code>, etc. matched with a serial number.</p> <p>Unfortunately, the manner that such category can be formatted is varied; thus requiring a combination of regex bases and a possible list of serial numbers.</p> <p>Since the serial number may consist of composite values, this needs to be processed separately as well.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class SerialPattern(BasePattern):\n\"\"\"A`Rule` can be extracted from a `SerialPattern`. The word \"serial\"\n    is employed because the documents representing rules are numbered consecutively.\n    Each serial pattern refers to a specific category, e.g. `RA`, `CA`, etc.\n    matched with a serial number.\n    Unfortunately, the manner that such category can be formatted is varied;\n    thus requiring a combination of regex bases and a possible\n    list of serial numbers.\n    Since the serial number may consist of composite values, this needs\n    to be processed separately as well.\n    \"\"\"\ncat: StatuteSerialCategory = Field(\n...,\ndescription=\"A type of rule from the taxonomy enumerated under StatuteSerialCategory.\",\n)\nregex_bases: list[str] = Field(\n...,\ndescription=\"There are too many ways to express a category name. There is a need to generate various regex strings which, when combined with the serial, can qualify for a serial rule.\",\n)\nregex_serials: list[str] = Field(\n...,\ndescription=\"The possible values of serial numbers to be matched with the regex_bases.\",\n)\n@property\ndef lines(self) -&gt; Iterator[str]:\n\"\"\"Each regex string produced matches the serial rule. Note the line break\n        needs to be retained so that when printing `@regex`, the result is organized.\n        \"\"\"\nfor base in self.regex_bases:\nfor idx in self.regex_serials:\nyield rf\"\"\"({base}\\s*{idx})\n                \"\"\"\n@property\ndef group_name(self) -&gt; str:\nreturn rf\"serial_{self.cat}\"\n@property\ndef regex(self) -&gt; str:\nreturn rf\"(?P&lt;{self.group_name}&gt;{r'|'.join(self.lines)})\"\n@property\ndef digits_in_match(self) -&gt; Pattern:\nreturn re.compile(r\"|\".join(self.regex_serials))\n</code></pre>"},{"location":"serial/#statute_patterns.models.SerialPattern-attributes","title":"Attributes","text":""},{"location":"serial/#statute_patterns.models.SerialPattern.lines","title":"<code>lines: Iterator[str]</code>  <code>property</code>","text":"<p>Each regex string produced matches the serial rule. Note the line break needs to be retained so that when printing <code>@regex</code>, the result is organized.</p>"},{"location":"serial/#serial-pattern-collection","title":"Serial Pattern Collection","text":"<p>         Bases: <code>BaseCollection</code></p> <p>Each category-based, serial-numbered, legal title will have a regex string, e.g. Republic Act is a category, a serial number for this category is 386 representing the Philippine Civil Code.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class SerialPatternCollection(BaseCollection):\n\"\"\"Each category-based, serial-numbered, legal title will have a\n    regex string, e.g. Republic Act is a category, a serial number for\n    this category is 386 representing the Philippine Civil Code.\"\"\"\ncollection: list[SerialPattern]\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\n\"\"\"Each `m`, a python Match object, represents a\n        serial pattern category with possible ambiguous identifier found.\n        So running `m.group(0)` should yield the entire text of the\n        match which consists of (a) the definitive category;\n        and (b) the ambiguous identifier.\n        The identifier is ambiguous because it may be a compound one,\n        e.g. 'Presidential Decree No. 1 and 2'. In this case, there\n        should be 2 matches produced not just one.\n        This function splits the identifier by commas `,` and the\n        word `and` to get the individual component identifiers.\n        \"\"\"\nfor match in self.pattern.finditer(text):\nfor sp in self.collection:\nif match.lastgroup == sp.group_name:\nif candidates := sp.digits_in_match.search(match.group(0)):\nfor d in split_digits(candidates.group(0)):\nc = sp.cat\nyield Rule(cat=c, id=d)\n</code></pre>"},{"location":"serial/#statute_patterns.models.SerialPatternCollection-functions","title":"Functions","text":""},{"location":"serial/#statute_patterns.models.SerialPatternCollection.extract_rules","title":"<code>extract_rules(text)</code>","text":"<p>Each <code>m</code>, a python Match object, represents a serial pattern category with possible ambiguous identifier found.</p> <p>So running <code>m.group(0)</code> should yield the entire text of the match which consists of (a) the definitive category; and (b) the ambiguous identifier.</p> <p>The identifier is ambiguous because it may be a compound one, e.g. 'Presidential Decree No. 1 and 2'. In this case, there should be 2 matches produced not just one.</p> <p>This function splits the identifier by commas <code>,</code> and the word <code>and</code> to get the individual component identifiers.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>def extract_rules(self, text: str) -&gt; Iterator[Rule]:\n\"\"\"Each `m`, a python Match object, represents a\n    serial pattern category with possible ambiguous identifier found.\n    So running `m.group(0)` should yield the entire text of the\n    match which consists of (a) the definitive category;\n    and (b) the ambiguous identifier.\n    The identifier is ambiguous because it may be a compound one,\n    e.g. 'Presidential Decree No. 1 and 2'. In this case, there\n    should be 2 matches produced not just one.\n    This function splits the identifier by commas `,` and the\n    word `and` to get the individual component identifiers.\n    \"\"\"\nfor match in self.pattern.finditer(text):\nfor sp in self.collection:\nif match.lastgroup == sp.group_name:\nif candidates := sp.digits_in_match.search(match.group(0)):\nfor d in split_digits(candidates.group(0)):\nc = sp.cat\nyield Rule(cat=c, id=d)\n</code></pre>"}]}