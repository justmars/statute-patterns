{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Summary","text":"<p>Detect titles of Philippine statutory text from given text input then generate a possible Path to extract statutory content.</p>"},{"location":"api-extract/","title":"Extraction","text":"<p>This presumes existence of a local path to a separate library where the contents of the rule can be extracted from.</p>"},{"location":"api-extract/#extract-rules","title":"Extract Rules","text":"<p>If text contains matching serialized (e.g. Republic Act No. 386) and named rules ('the Civil Code of the Philippines'), produce both.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from statute_patterns import extract_rules\n&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; list(extract_rules(text)) # get all rules\n[\n    Rule(cat='ra', id='386'),\n    Rule(cat='ra', id='386'),\n    Rule(cat='spain', id='civil')\n]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for statute patterns.</p> required <p>Yields:</p> Type Description <code>Iterator[Rule]</code> <p>Iterator[Rule]: Serialized Rules and Named Rule patterns</p> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def extract_rules(text: str) -&gt; Iterator[Rule]:\n\"\"\"If text contains matching serialized (e.g. Republic Act No. 386)\n    and named rules ('the Civil Code of the Philippines'), produce both.\n    Examples:\n        &gt;&gt;&gt; from statute_patterns import extract_rules\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; list(extract_rules(text)) # get all rules\n        [\n            Rule(cat='ra', id='386'),\n            Rule(cat='ra', id='386'),\n            Rule(cat='spain', id='civil')\n        ]\n    Args:\n        text (str): Text to search for statute patterns.\n    Yields:\n        Iterator[Rule]: Serialized Rules and Named Rule patterns\n    \"\"\"\nyield from SerializedRules.extract_rules(text)\nyield from NamedRules.extract_rules(text)\n</code></pre>"},{"location":"api-extract/#extract-rule","title":"Extract Rule","text":"<p>Thin wrapper over <code>extract_rules()</code>. If text contains a matching rule, get the first rule found.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from statute_patterns import extract_rule\n&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; extract_rule(text)  # get the first matching rule\nRule(cat='ra', id='386')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for statute patterns.</p> required <p>Returns:</p> Type Description <code>Rule | None</code> <p>Rule | None: The first serialized rule or named rule found, if it exists</p> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def extract_rule(text: str) -&gt; Rule | None:\n\"\"\"Thin wrapper over `extract_rules()`. If text contains a\n    matching rule, get the first rule found.\n    Examples:\n        &gt;&gt;&gt; from statute_patterns import extract_rule\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; extract_rule(text)  # get the first matching rule\n        Rule(cat='ra', id='386')\n    Args:\n        text (str): Text to search for statute patterns.\n    Returns:\n        Rule | None: The first serialized rule or named rule found, if it exists\n    \"\"\"\ntry:\nreturn next(extract_rules(text))\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"api-extract/#count-rules","title":"Count Rules","text":"<p>Based on results from <code>extract_rules(text)</code>, get the count of each unique rule found.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from statute_patterns import count_rules\n&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; list(count_rules(text)): # get unique rules with counts\n[\n    {'cat': 'ra', 'id': '386', 'mentions': 2},\n    {'cat': 'spain', 'id': 'civil', 'mentions': 1}\n]\n</code></pre> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def count_rules(text: str) -&gt; Iterator[dict]:\n\"\"\"Based on results from `extract_rules(text)`, get the count of each unique rule found.\n    Examples:\n        &gt;&gt;&gt; from statute_patterns import count_rules\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; list(count_rules(text)): # get unique rules with counts\n        [\n            {'cat': 'ra', 'id': '386', 'mentions': 2},\n            {'cat': 'spain', 'id': 'civil', 'mentions': 1}\n        ]\n    \"\"\"\nfor k, v in Counter(extract_rules(text)).items():\nyield k.dict() | {\"mentions\": v}\n</code></pre>"},{"location":"api-extract/#detail-rule","title":"Detail Rule","text":"<p>We can extract the details of the rule with the <code>StatuteDetails.from_rule()</code> also accessible via <code>Rule.get_details()</code>:</p> Python<pre><code>&gt;&gt;&gt;from statute_patterns import StatuteDetails\n&gt;&gt;&gt;StatuteDetails.from_rule(rule_obj, &lt;path/to/statutes&gt;) # or rule_obj.get_details(&lt;path/to/details&gt;)\nStatuteDetails(\ncreated=1665225124.0644598,\nmodified=1665225124.0644598,\nrule=Rule(cat='ra', id='386'),\ntitle='Republic Act No. 386',\ndescription='An Act to Ordain and Institute the Civil Code of the Philippines',\nid='ra-386-june-18-1949',\nemails=['maria@abcxyz.law', 'fernando@abcxyz.law'],\ndate=datetime.date(1949, 6, 18),\nvariant=1,\nunits=[\n{\n'item': 'Container 1',\n'caption': 'Preliminary Title',\n'units': [\n{\n'item': 'Chapter 1',\n'caption': 'Effect and Application of Laws',\n'units': [\n{\n'item': 'Article 1',\n'content': 'This Act shall be known as the \"Civil Code of the Philippines.\" (n)\\n'\n},\n{\n'item': 'Article 2',\n'content': 'Laws shall take effect after fifteen days following the completion of their publication either in the Official Gazette or in a newspaper of general circulation in the Philippines, unless it is otherwise provided. (1a)\\n'\n},\n...\n]\n},\n...\n]\n},\n...\n],\ntitles=[\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='alias',\ntext='New Civil Code'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='alias',\ntext='Civil Code of 1950'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='official',\ntext='An Act to Ordain and Institute the Civil Code of the Philippines'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='serial',\ntext='Republic Act No. 386'\n)\n]\n)\n</code></pre>"},{"location":"api-extract/#statutedetails","title":"StatuteDetails","text":"<p>         Bases: <code>BaseModel</code></p> <p>Based on a <code>Rule</code> object, obtain details loaded from files found in a Rule's proper path; the <code>description</code> field is relevant as the source material for the statute's serial title.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>class StatuteDetails(BaseModel):\n\"\"\"\n    Based on a `Rule` object, obtain details loaded from files found in a\n    Rule's proper path; the `description` field is relevant as the source\n    material for the statute's serial title.\n    \"\"\"\ncreated: float\nmodified: float\nrule: Rule\ntitle: str\ndescription: str\nid: str\nemails: list[EmailStr]\ndate: datetime.date\nvariant: int\ntitles: list[StatuteTitle]\nunits: list[dict]\n@classmethod\ndef slug_id(cls, p: Path, dt: str, v: int | None):\n\"\"\"Use the path's parameters with the date and variant, to\n        create a slug that can serve as the url / primary key of the\n        statute.\"\"\"\n_temp = [p.parent.parent.stem, p.parent.stem, dt]\nif v:\n_temp.append(str(v))\nreturn slugify(\" \".join(_temp))\n@classmethod\ndef from_rule(cls, rule: Rule, base_path: Path = STATUTE_PATH):\n\"\"\"From a constructed rule (see `Rule.from_path()`), get the\n        details of said rule.  Limitation: the category and identifier must\n        be unique.\"\"\"\nif not base_path.exists():\nraise Exception(f\"Could not get proper {base_path=}.\")\nif not rule.serial_title:\nraise Exception(\"No serial title created.\")\n_file = None\nif folder := rule.get_path(base_path):\n_file = folder / DETAILS_FILE\nif not _file or not _file.exists():\nraise Exception(f\"No _file found from {folder=} {base_path=}.\")\nd = yaml.safe_load(_file.read_bytes())\ndt, ofc_title, v = d.get(\"date\"), d.get(\"law_title\"), d.get(\"variant\")\nif not all([ofc_title, dt]):\nraise Exception(f\"Fail on: {dt=}, {ofc_title=}, {v=}\")\nunits = set_units(ofc_title, rule.units_path(_file.parent))\nidx = cls.slug_id(_file, dt, v)\ntitles = StatuteTitle.generate(\npk=idx,\nofficial=ofc_title,\nserial=rule.serial_title,\nshort=get_short(units),\naliases=d.get(\"aliases\"),\n)\nreturn cls(\ncreated=_file.stat().st_ctime,\nmodified=_file.stat().st_mtime,\nrule=rule,\nid=idx,\ntitle=rule.serial_title,\ndescription=ofc_title,\nemails=d.get(\"emails\", [\"bot@lawsql.com\"]),  # default to generic\ndate=parse(d[\"date\"]).date(),\nvariant=v or 1,  # default to 1\nunits=units,\ntitles=list(titles),\n)\n</code></pre>"},{"location":"api-extract/#statute_patterns.StatuteDetails-functions","title":"Functions","text":""},{"location":"api-extract/#statute_patterns.components.details.StatuteDetails.from_rule","title":"<code>from_rule(rule, base_path=STATUTE_PATH)</code>  <code>classmethod</code>","text":"<p>From a constructed rule (see <code>Rule.from_path()</code>), get the details of said rule.  Limitation: the category and identifier must be unique.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>@classmethod\ndef from_rule(cls, rule: Rule, base_path: Path = STATUTE_PATH):\n\"\"\"From a constructed rule (see `Rule.from_path()`), get the\n    details of said rule.  Limitation: the category and identifier must\n    be unique.\"\"\"\nif not base_path.exists():\nraise Exception(f\"Could not get proper {base_path=}.\")\nif not rule.serial_title:\nraise Exception(\"No serial title created.\")\n_file = None\nif folder := rule.get_path(base_path):\n_file = folder / DETAILS_FILE\nif not _file or not _file.exists():\nraise Exception(f\"No _file found from {folder=} {base_path=}.\")\nd = yaml.safe_load(_file.read_bytes())\ndt, ofc_title, v = d.get(\"date\"), d.get(\"law_title\"), d.get(\"variant\")\nif not all([ofc_title, dt]):\nraise Exception(f\"Fail on: {dt=}, {ofc_title=}, {v=}\")\nunits = set_units(ofc_title, rule.units_path(_file.parent))\nidx = cls.slug_id(_file, dt, v)\ntitles = StatuteTitle.generate(\npk=idx,\nofficial=ofc_title,\nserial=rule.serial_title,\nshort=get_short(units),\naliases=d.get(\"aliases\"),\n)\nreturn cls(\ncreated=_file.stat().st_ctime,\nmodified=_file.stat().st_mtime,\nrule=rule,\nid=idx,\ntitle=rule.serial_title,\ndescription=ofc_title,\nemails=d.get(\"emails\", [\"bot@lawsql.com\"]),  # default to generic\ndate=parse(d[\"date\"]).date(),\nvariant=v or 1,  # default to 1\nunits=units,\ntitles=list(titles),\n)\n</code></pre>"},{"location":"api-extract/#statute_patterns.components.details.StatuteDetails.slug_id","title":"<code>slug_id(p, dt, v)</code>  <code>classmethod</code>","text":"<p>Use the path's parameters with the date and variant, to create a slug that can serve as the url / primary key of the statute.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>@classmethod\ndef slug_id(cls, p: Path, dt: str, v: int | None):\n\"\"\"Use the path's parameters with the date and variant, to\n    create a slug that can serve as the url / primary key of the\n    statute.\"\"\"\n_temp = [p.parent.parent.stem, p.parent.stem, dt]\nif v:\n_temp.append(str(v))\nreturn slugify(\" \".join(_temp))\n</code></pre>"},{"location":"api-rule-base/","title":"Abstract Rules","text":""},{"location":"api-rule-base/#base-pattern","title":"Base Pattern","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BasePattern(BaseModel, abc.ABC):\nmatches: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should_ match regex property.\",\n)\nexcludes: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should not_ match regex property.\",\n)\nclass Config:\nuse_enum_values = True\ndef __init__(self, **kwargs):\nsuper().__init__(**kwargs)\nself.validate_matches()\nself.validate_excludes()\n@property\n@abc.abstractmethod\ndef regex(self) -&gt; str:\n\"\"\"Combines the group_name with the desired regex string.\"\"\"\nraise NotImplementedError(\n\"Base regex to be later combined with other rules regex strings.\"\n)\n@property\n@abc.abstractmethod\ndef group_name(self) -&gt; str:\n\"\"\"Added to regex string to identify the `match.lastgroup`\"\"\"\nraise NotImplementedError(\"Used to identify `regex` capture group.\")\n@property\ndef pattern(self) -&gt; Pattern:\n\"\"\"Enables use of a unique Pattern object per rule pattern created,\n        regardless of it being a SerialPattern or a NamedPattern.\"\"\"\nreturn re.compile(self.regex, re.X)\ndef validate_matches(self) -&gt; None:\nfor example_text in self.matches:\nif not self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Missing match but intended to be included: {example_text}\"\n)\ndef validate_excludes(self) -&gt; None:\nfor example_text in self.excludes:\nif self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Match found even if intended to be excluded: {example_text}.\"\n)\n</code></pre>"},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern-attributes","title":"Attributes","text":""},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern.group_name","title":"<code>group_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Added to regex string to identify the <code>match.lastgroup</code></p>"},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern.pattern","title":"<code>pattern: Pattern</code>  <code>property</code>","text":"<p>Enables use of a unique Pattern object per rule pattern created, regardless of it being a SerialPattern or a NamedPattern.</p>"},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern.regex","title":"<code>regex: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Combines the group_name with the desired regex string.</p>"},{"location":"api-rule-base/#base-collection","title":"Base Collection","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> <p>Whether a collection of Named or Serial patterns are instantiated, a <code>combined_regex</code> property and a <code>pattern</code> propery will be automatically created based on the collection of objects declared on instantiation of the class.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BaseCollection(BaseModel, abc.ABC):\n\"\"\"Whether a collection of Named or Serial patterns are instantiated,\n    a `combined_regex` property and a `pattern` propery will be automatically\n    created based on the collection of objects declared on instantiation\n    of the class.\"\"\"\ncollection: list = NotImplemented\n@abc.abstractmethod\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\nraise NotImplementedError(\"Need ability to fetch Rule objects.\")\n@property\ndef combined_regex(self) -&gt; str:\n\"\"\"Combine the different items in the collection\n        (having .regex attribute) to form a single regex string.\"\"\"\nreturn \"|\".join([r.regex for r in self.collection])\n@property\ndef pattern(self) -&gt; Pattern:\nreturn re.compile(self.combined_regex, re.X)\n</code></pre>"},{"location":"api-rule-base/#statute_patterns.components.rule.BaseCollection-attributes","title":"Attributes","text":""},{"location":"api-rule-base/#statute_patterns.components.rule.BaseCollection.combined_regex","title":"<code>combined_regex: str</code>  <code>property</code>","text":"<p>Combine the different items in the collection (having .regex attribute) to form a single regex string.</p>"},{"location":"api-rule-named/","title":"Named Statutes","text":""},{"location":"api-rule-named/#named-pattern","title":"Named Pattern","text":"<p>         Bases: <code>BasePattern</code></p> <p>A<code>Rule</code> can be extracted from a <code>NamedPattern</code></p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class NamedPattern(BasePattern):\n\"\"\"A`Rule` can be extracted from a `NamedPattern`\"\"\"\nname: str\nregex_base: str\nrule: Rule\n@property\ndef regex(self) -&gt; str:\nreturn stx(rf\"(?P&lt;{self.group_name}&gt;{self.regex_base})\")\n@property\ndef group_name(self) -&gt; str:\ntexts = \" \".join([self.rule.cat, self.rule.id])\nreturn slugify(texts, separator=\"_\", lowercase=True)\n</code></pre>"},{"location":"api-rule-named/#named-statute-collection","title":"Named Statute Collection","text":"<p>         Bases: <code>BaseCollection</code></p> <p>Each named legal title, not falling under the SerialNames Patterns, will also have its own manually crafted regex string. Examples include 'the Spanish Civil Code' or the '1987 Constitution' or the 'Code of Professional Responsibility'.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class NamedPatternCollection(BaseCollection):\n\"\"\"Each named legal title, not falling under the SerialNames Patterns, will also have its own manually crafted regex string. Examples include 'the Spanish Civil Code' or the '1987 Constitution' or the 'Code of Professional Responsibility'.\"\"\"\ncollection: list[NamedPattern]\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\nfor m in self.pattern.finditer(text):\nfor named in self.collection:\nif m.lastgroup == named.group_name:\nyield named.rule\n</code></pre>"},{"location":"api-rule-serial/","title":"Serialized Statutes","text":""},{"location":"api-rule-serial/#statute-serial-category","title":"Statute Serial Category","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api-rule-serial/#statute_patterns.components.category.StatuteSerialCategory--concept","title":"Concept","text":"<p>It would be difficult to identify rules if they were arbitrarily named without a fixed point of reference. For instance the \"Civil Code of the Philippines\",  an arbitrary collection of letters, would be hard to find if laws were organized alphabetically.</p> <p>Fortunately, each Philippine <code>serial</code>-title rule belongs to an assignable <code>StatuteSerialCategory</code>. This is not an official reference but rather a non-exhaustive taxonomy of Philippine legal rules mapped to a <code>enum.Enum</code> object.</p> Enum Purpose <code>name</code> for most members, can \"uncamel\"-ized to produce serial title <code>value</code> (a) folder for discovering path / (b) category usable in the database table <p>Using this model simplifies the ability to navigate rules. Going back to the Civil Code described above, its <code>serial</code> title is Republic Act No. 386 and thus can be mapped to the following folder: <code>/statutes/ra/386</code>. We can definitely categorize this as an ra with a serial id of 386.</p> <p>Mapped to its <code>Rule</code>, counterpart we get:</p> Field Value Description <code>cat</code> ra Serial statute category <code>id</code> 386 Serial identifier of the category"},{"location":"api-rule-serial/#statute_patterns.components.category.StatuteSerialCategory--purpose","title":"Purpose","text":"<p>Knowing the path to a rule, we can later extract the rule's contents. (Note however that there can be more than one path since in exceptional cases, the combination of category + serial id does not yield a unique rule.)</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; StatuteSerialCategory\n&lt;enum 'StatuteSerialCategory'&gt;\n&gt;&gt;&gt; StatuteSerialCategory._member_map_\n{'RepublicAct': &lt;StatuteSerialCategory.RepublicAct: 'ra'&gt;, 'CommonwealthAct': &lt;StatuteSerialCategory.CommonwealthAct: 'ca'&gt;, 'Act': &lt;StatuteSerialCategory.Act: 'act'&gt;, 'Constitution': &lt;StatuteSerialCategory.Constitution: 'const'&gt;, 'Spain': &lt;StatuteSerialCategory.Spain: 'spain'&gt;, 'BatasPambansa': &lt;StatuteSerialCategory.BatasPambansa: 'bp'&gt;, 'PresidentialDecree': &lt;StatuteSerialCategory.PresidentialDecree: 'pd'&gt;, 'ExecutiveOrder': &lt;StatuteSerialCategory.ExecutiveOrder: 'eo'&gt;, 'LetterOfInstruction': &lt;StatuteSerialCategory.LetterOfInstruction: 'loi'&gt;, 'VetoMessage': &lt;StatuteSerialCategory.VetoMessage: 'veto'&gt;, 'RulesOfCourt': &lt;StatuteSerialCategory.RulesOfCourt: 'roc'&gt;, 'BarMatter': &lt;StatuteSerialCategory.BarMatter: 'rule_bm'&gt;, 'AdministrativeMatter': &lt;StatuteSerialCategory.AdministrativeMatter: 'rule_am'&gt;, 'ResolutionEnBanc': &lt;StatuteSerialCategory.ResolutionEnBanc: 'rule_reso'&gt;, 'CircularOCA': &lt;StatuteSerialCategory.CircularOCA: 'oca_cir'&gt;, 'CircularSC': &lt;StatuteSerialCategory.CircularSC: 'sc_cir'&gt;}\n</code></pre> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>class StatuteSerialCategory(str, Enum):\n\"\"\"\n    ## Concept\n    It would be difficult to identify rules if they were arbitrarily named\n    without a fixed point of reference. For instance the \"Civil Code of the\n    Philippines\",  an arbitrary collection of letters, would be hard to find\n    if laws were organized alphabetically.\n    Fortunately, each Philippine `serial`-title rule belongs to an\n    assignable `StatuteSerialCategory`. This is not an official reference but\n    rather a non-exhaustive taxonomy of Philippine legal rules mapped to\n    a `enum.Enum` object.\n    Enum | Purpose\n    --:|:--\n    `name` | for _most_ members, can \"uncamel\"-ized to produce serial title\n    `value` | (a) folder for discovering path / (b) category usable in the database table\n    Using this model simplifies the ability to navigate rules. Going back to\n    the Civil Code described above, its `serial` title is _Republic Act No. 386_ and\n    thus can be mapped to the following folder: `/statutes/ra/386`. We can definitely\n    categorize this as an _ra_ with a serial id of _386_.\n    Mapped to its `Rule`, counterpart we get:\n    Field | Value | Description\n    :--:|:--:|:--\n    `cat`| ra | Serial statute category\n    `id` | 386 | Serial identifier of the category\n    ## Purpose\n    Knowing the path to a rule, we can later extract the rule's contents. (Note however that there can be more than one path since in exceptional cases, the combination of *category* + *serial id* does not yield a unique rule.)\n    Examples:\n        &gt;&gt;&gt; StatuteSerialCategory\n        &lt;enum 'StatuteSerialCategory'&gt;\n        &gt;&gt;&gt; StatuteSerialCategory._member_map_\n        {'RepublicAct': &lt;StatuteSerialCategory.RepublicAct: 'ra'&gt;, 'CommonwealthAct': &lt;StatuteSerialCategory.CommonwealthAct: 'ca'&gt;, 'Act': &lt;StatuteSerialCategory.Act: 'act'&gt;, 'Constitution': &lt;StatuteSerialCategory.Constitution: 'const'&gt;, 'Spain': &lt;StatuteSerialCategory.Spain: 'spain'&gt;, 'BatasPambansa': &lt;StatuteSerialCategory.BatasPambansa: 'bp'&gt;, 'PresidentialDecree': &lt;StatuteSerialCategory.PresidentialDecree: 'pd'&gt;, 'ExecutiveOrder': &lt;StatuteSerialCategory.ExecutiveOrder: 'eo'&gt;, 'LetterOfInstruction': &lt;StatuteSerialCategory.LetterOfInstruction: 'loi'&gt;, 'VetoMessage': &lt;StatuteSerialCategory.VetoMessage: 'veto'&gt;, 'RulesOfCourt': &lt;StatuteSerialCategory.RulesOfCourt: 'roc'&gt;, 'BarMatter': &lt;StatuteSerialCategory.BarMatter: 'rule_bm'&gt;, 'AdministrativeMatter': &lt;StatuteSerialCategory.AdministrativeMatter: 'rule_am'&gt;, 'ResolutionEnBanc': &lt;StatuteSerialCategory.ResolutionEnBanc: 'rule_reso'&gt;, 'CircularOCA': &lt;StatuteSerialCategory.CircularOCA: 'oca_cir'&gt;, 'CircularSC': &lt;StatuteSerialCategory.CircularSC: 'sc_cir'&gt;}\n    \"\"\"  # noqa: E501\nRepublicAct = \"ra\"\nCommonwealthAct = \"ca\"\nAct = \"act\"\nConstitution = \"const\"\nSpain = \"spain\"\nBatasPambansa = \"bp\"\nPresidentialDecree = \"pd\"\nExecutiveOrder = \"eo\"\nLetterOfInstruction = \"loi\"\nVetoMessage = \"veto\"\nRulesOfCourt = \"roc\"\nBarMatter = \"rule_bm\"\nAdministrativeMatter = \"rule_am\"\nResolutionEnBanc = \"rule_reso\"\nCircularOCA = \"oca_cir\"\nCircularSC = \"sc_cir\"\ndef serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n        Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n        1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n        2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n        \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"api-rule-serial/#statute_patterns.components.category.StatuteSerialCategory-functions","title":"Functions","text":""},{"location":"api-rule-serial/#statute_patterns.components.category.StatuteSerialCategory.serialize","title":"<code>serialize(idx)</code>","text":"<p>Given a member item and a valid serialized identifier, create a serial title.</p> <p>Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.</p> <ol> <li><code>pd</code> + <code>570-a</code> = <code>Presidential Decree No. 570-A</code></li> <li><code>rule_am</code> + <code>03-06-13-sc</code> = <code>Administrative Matter No. 03-06-13-SC</code></li> </ol> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>def serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n    Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n    1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n    2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n    \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"api-rule-serial/#serial-pattern","title":"Serial Pattern","text":"<p>         Bases: <code>BasePattern</code></p> <p>A<code>Rule</code> can be extracted from a <code>SerialPattern</code>. The word \"serial\" is employed because the documents representing rules are numbered consecutively.</p> <p>Each serial pattern refers to a specific category, e.g. <code>RA</code>, <code>CA</code>, etc. matched with a serial number.</p> <p>Unfortunately, the manner that such category can be formatted is varied; thus requiring a combination of regex bases and a possible list of serial numbers.</p> <p>Since the serial number may consist of composite values, this needs to be processed separately as well.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class SerialPattern(BasePattern):\n\"\"\"A`Rule` can be extracted from a `SerialPattern`. The word \"serial\"\n    is employed because the documents representing rules are numbered consecutively.\n    Each serial pattern refers to a specific category, e.g. `RA`, `CA`, etc.\n    matched with a serial number.\n    Unfortunately, the manner that such category can be formatted is varied;\n    thus requiring a combination of regex bases and a possible\n    list of serial numbers.\n    Since the serial number may consist of composite values, this needs\n    to be processed separately as well.\n    \"\"\"\ncat: StatuteSerialCategory = Field(\n...,\ndescription=\"A type of rule from the taxonomy enumerated under StatuteSerialCategory.\",\n)\nregex_bases: list[str] = Field(\n...,\ndescription=\"There are too many ways to express a category name. There is a need to generate various regex strings which, when combined with the serial, can qualify for a serial rule.\",\n)\nregex_serials: list[str] = Field(\n...,\ndescription=\"The possible values of serial numbers to be matched with the regex_bases.\",\n)\n@property\ndef lines(self) -&gt; Iterator[str]:\n\"\"\"Each regex string produced matches the serial rule. Note the line break\n        needs to be retained so that when printing `@regex`, the result is organized.\n        \"\"\"\nfor base in self.regex_bases:\nfor idx in self.regex_serials:\nyield rf\"\"\"({base}\\s*{idx})\n                \"\"\"\n@property\ndef group_name(self) -&gt; str:\nreturn rf\"serial_{self.cat}\"\n@property\ndef regex(self) -&gt; str:\nreturn rf\"(?P&lt;{self.group_name}&gt;{r'|'.join(self.lines)})\"\n@property\ndef digits_in_match(self) -&gt; Pattern:\nreturn re.compile(r\"|\".join(self.regex_serials))\n</code></pre>"},{"location":"api-rule-serial/#statute_patterns.models.SerialPattern-attributes","title":"Attributes","text":""},{"location":"api-rule-serial/#statute_patterns.models.SerialPattern.lines","title":"<code>lines: Iterator[str]</code>  <code>property</code>","text":"<p>Each regex string produced matches the serial rule. Note the line break needs to be retained so that when printing <code>@regex</code>, the result is organized.</p>"},{"location":"api-rule-serial/#serial-pattern-collection","title":"Serial Pattern Collection","text":"<p>         Bases: <code>BaseCollection</code></p> <p>Each category-based, serial-numbered, legal title will have a regex string, e.g. Republic Act is a category, a serial number for this category is 386 representing the Philippine Civil Code.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class SerialPatternCollection(BaseCollection):\n\"\"\"Each category-based, serial-numbered, legal title will have a\n    regex string, e.g. Republic Act is a category, a serial number for\n    this category is 386 representing the Philippine Civil Code.\"\"\"\ncollection: list[SerialPattern]\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\n\"\"\"Each `m`, a python Match object, represents a\n        serial pattern category with possible ambiguous identifier found.\n        So running `m.group(0)` should yield the entire text of the\n        match which consists of (a) the definitive category;\n        and (b) the ambiguous identifier.\n        The identifier is ambiguous because it may be a compound one,\n        e.g. 'Presidential Decree No. 1 and 2'. In this case, there\n        should be 2 matches produced not just one.\n        This function splits the identifier by commas `,` and the\n        word `and` to get the individual component identifiers.\n        \"\"\"\nfor match in self.pattern.finditer(text):\nfor sp in self.collection:\nif match.lastgroup == sp.group_name:\nif candidates := sp.digits_in_match.search(match.group(0)):\nfor d in split_digits(candidates.group(0)):\nc = sp.cat\nyield Rule(cat=c, id=d)\n</code></pre>"},{"location":"api-rule-serial/#statute_patterns.models.SerialPatternCollection-functions","title":"Functions","text":""},{"location":"api-rule-serial/#statute_patterns.models.SerialPatternCollection.extract_rules","title":"<code>extract_rules(text)</code>","text":"<p>Each <code>m</code>, a python Match object, represents a serial pattern category with possible ambiguous identifier found.</p> <p>So running <code>m.group(0)</code> should yield the entire text of the match which consists of (a) the definitive category; and (b) the ambiguous identifier.</p> <p>The identifier is ambiguous because it may be a compound one, e.g. 'Presidential Decree No. 1 and 2'. In this case, there should be 2 matches produced not just one.</p> <p>This function splits the identifier by commas <code>,</code> and the word <code>and</code> to get the individual component identifiers.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>def extract_rules(self, text: str) -&gt; Iterator[Rule]:\n\"\"\"Each `m`, a python Match object, represents a\n    serial pattern category with possible ambiguous identifier found.\n    So running `m.group(0)` should yield the entire text of the\n    match which consists of (a) the definitive category;\n    and (b) the ambiguous identifier.\n    The identifier is ambiguous because it may be a compound one,\n    e.g. 'Presidential Decree No. 1 and 2'. In this case, there\n    should be 2 matches produced not just one.\n    This function splits the identifier by commas `,` and the\n    word `and` to get the individual component identifiers.\n    \"\"\"\nfor match in self.pattern.finditer(text):\nfor sp in self.collection:\nif match.lastgroup == sp.group_name:\nif candidates := sp.digits_in_match.search(match.group(0)):\nfor d in split_digits(candidates.group(0)):\nc = sp.cat\nyield Rule(cat=c, id=d)\n</code></pre>"},{"location":"api-rule/","title":"Rule","text":""},{"location":"api-rule/#rule-model","title":"Rule Model","text":"<p>         Bases: <code>BaseModel</code></p> <p>Created primarily via <code>NamedPatternCollection</code> or a <code>SerialPatternCollection</code>, a <code>Rule</code> has many use cases:</p> <ol> <li>Prior validation by <code>NamedPattern</code> or a <code>SerialPattern</code> regex strings with Pydantic validation.</li> <li>Ensure a consistent path to an intended local directory via a uniform <code>StatuteSerialCategory</code> folder (<code>cat</code>) and a target serialized statute (<code>id</code>).</li> <li>Extract the details and units files from the path designated.</li> <li>Generate a serial title based on the <code>StatuteSerialCategory.serialize()</code> function.</li> <li>Be an exceptional Pydantic BaseModel which is countable through the collection.Counter built-in.</li> </ol> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class Rule(BaseModel):\n\"\"\"Created primarily via `NamedPatternCollection` or\n    a `SerialPatternCollection`, a `Rule` has many use cases:\n    1. Prior validation by `NamedPattern` or a `SerialPattern` regex strings with Pydantic validation.\n    2. Ensure a consistent path to an intended local directory via a uniform `StatuteSerialCategory` folder (`cat`) and a target serialized statute (`id`).\n    3. Extract the details and units files from the path designated.\n    4. Generate a serial title based on the `StatuteSerialCategory.serialize()` function.\n    5. Be an exceptional Pydantic BaseModel which is countable through the collection.Counter built-in.\n    \"\"\"\ncat: StatuteSerialCategory = Field(\n...,\ntitle=\"Statute Category\",\ndescription=\"Classification under the limited StatuteSerialCategory taxonomy.\",\n)\nid: constr(to_lower=True) = Field(  # type: ignore\n...,\ntitle=\"Serial Identifier\",\ndescription=\"Limited inclusion of identifiers, e.g. only a subset of Executive Orders, Letters of Instruction, Spanish Codes will be permitted.\",\n)\nclass Config:\nuse_enum_values = True\ndef __hash__(self):\n\"\"\"Pydantic models are not hashable by default. The implementation in this case becomes useful for the built-in collections.Counter (used in statute_patterns.count_rules). See https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964.\"\"\"\nreturn hash((type(self),) + tuple(self.__dict__.values()))\n@validator(\"cat\", pre=True)\ndef category_in_lower_case(cls, v):\nreturn StatuteSerialCategory(v.lower())\n@validator(\"id\", pre=True)\ndef serial_id_lower(cls, v):\nreturn v.lower()\n@classmethod\ndef get_details(cls, details_path: Path):\n\"\"\"Assumes a properly structured path with three path\n        parents from details.yaml, e.g. path to `/statutes/ra/386/details.yaml`\n        means 3 parents from the same would be /statutes. Will\n        create the rule based on the details path and pull data from other\n        related paths to generate the details of the rule.\"\"\"\nfrom .details import StatuteDetails\nif rule := cls.from_path(details_path):\nstatute_path = details_path.parent.parent.parent\nreturn StatuteDetails.from_rule(rule, statute_path)\nreturn None\n@classmethod\ndef from_path(cls, details_path: Path):\n\"\"\"Construct rule from a properly structured statute's `details.yaml` file.\"\"\"\ndir = details_path.parent\ncat = dir.parent.stem\nidx = dir.stem\nif details_path.name == DETAILS_FILE:\nreturn cls(cat=StatuteSerialCategory(cat), id=idx)\nreturn None\n@property\ndef serial_title(self):\nreturn StatuteSerialCategory(self.cat).serialize(self.id)\ndef get_path(self, base_path: Path = STATUTE_PATH) -&gt; Path | None:\n\"\"\"For most cases, there only be one path to path/to/statutes/ra/386 where:\n        1. path/to/statutes = base_path\n        2. 'ra' is the category\n        3. '386' is the id.\n        \"\"\"\ntarget = base_path / self.cat / self.id\nif target.exists():\nreturn target\nreturn None\ndef get_paths(self, base_path: Path = STATUTE_PATH) -&gt; list[Path]:\n\"\"\"The serial id isn't enough in complex statutes.\n        To simplify, imagine Statute A, B and C have the same\n        category and identifier. But refer to different documents.\n        Because of this dilemma, we introduce a digit in the creation of statute\n        folders referring to more than one variant of the intended document.\n        So in the case of `/statutes/rule_am/`, let's consider `00-5-03-sc`.\n        This should be valid statute under `self.get_path()`.\n        However, since there exists 2 variants, we need to rename the original\n        folder to contemplate 2 distinct documents:\n        1. statutes/rule_am/00-5-03-sc-1\n        2. statutes/rule_am/00-5-03-sc-2\n        Both folders will be retrieved using the plural form of\n        the function `self.get_paths()`\n        \"\"\"\ntargets = []\ntarget = base_path / self.cat\npaths = target.glob(f\"{self.id}-*/{DETAILS_FILE}\")\nfor variant_path in paths:\nif variant_path.exists():\ntargets.append(variant_path.parent)\nreturn targets\ndef extract_folders(\nself, base_path: Path = STATUTE_PATH\n) -&gt; Iterator[Path]:\n\"\"\"Using the `category` and `id` of the object,\n        get the possible folder paths.\"\"\"\nif folder := self.get_path(base_path):\nyield folder\nelse:\nif folders := self.get_paths(base_path):\nyield from folders\ndef units_path(self, statute_folder: Path) -&gt; Path | None:\n\"\"\"There are two kinds of unit files: the preferred / customized\n        variant and the one scraped (the default in the absence of a preferred\n        variant).\"\"\"\npreferred = statute_folder / f\"{self.cat}{self.id}.yaml\"\nif preferred.exists():\nreturn preferred\ndefault = statute_folder / \"units.yaml\"\nif default.exists():\nreturn default\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule-functions","title":"Functions","text":""},{"location":"api-rule/#statute_patterns.components.rule.Rule.__hash__","title":"<code>__hash__()</code>","text":"<p>Pydantic models are not hashable by default. The implementation in this case becomes useful for the built-in collections.Counter (used in statute_patterns.count_rules). See https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def __hash__(self):\n\"\"\"Pydantic models are not hashable by default. The implementation in this case becomes useful for the built-in collections.Counter (used in statute_patterns.count_rules). See https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964.\"\"\"\nreturn hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.extract_folders","title":"<code>extract_folders(base_path=STATUTE_PATH)</code>","text":"<p>Using the <code>category</code> and <code>id</code> of the object, get the possible folder paths.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def extract_folders(\nself, base_path: Path = STATUTE_PATH\n) -&gt; Iterator[Path]:\n\"\"\"Using the `category` and `id` of the object,\n    get the possible folder paths.\"\"\"\nif folder := self.get_path(base_path):\nyield folder\nelse:\nif folders := self.get_paths(base_path):\nyield from folders\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.from_path","title":"<code>from_path(details_path)</code>  <code>classmethod</code>","text":"<p>Construct rule from a properly structured statute's <code>details.yaml</code> file.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>@classmethod\ndef from_path(cls, details_path: Path):\n\"\"\"Construct rule from a properly structured statute's `details.yaml` file.\"\"\"\ndir = details_path.parent\ncat = dir.parent.stem\nidx = dir.stem\nif details_path.name == DETAILS_FILE:\nreturn cls(cat=StatuteSerialCategory(cat), id=idx)\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.get_details","title":"<code>get_details(details_path)</code>  <code>classmethod</code>","text":"<p>Assumes a properly structured path with three path parents from details.yaml, e.g. path to <code>/statutes/ra/386/details.yaml</code> means 3 parents from the same would be /statutes. Will create the rule based on the details path and pull data from other related paths to generate the details of the rule.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>@classmethod\ndef get_details(cls, details_path: Path):\n\"\"\"Assumes a properly structured path with three path\n    parents from details.yaml, e.g. path to `/statutes/ra/386/details.yaml`\n    means 3 parents from the same would be /statutes. Will\n    create the rule based on the details path and pull data from other\n    related paths to generate the details of the rule.\"\"\"\nfrom .details import StatuteDetails\nif rule := cls.from_path(details_path):\nstatute_path = details_path.parent.parent.parent\nreturn StatuteDetails.from_rule(rule, statute_path)\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.get_path","title":"<code>get_path(base_path=STATUTE_PATH)</code>","text":"<p>For most cases, there only be one path to path/to/statutes/ra/386 where:</p> <ol> <li>path/to/statutes = base_path</li> <li>'ra' is the category</li> <li>'386' is the id.</li> </ol> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def get_path(self, base_path: Path = STATUTE_PATH) -&gt; Path | None:\n\"\"\"For most cases, there only be one path to path/to/statutes/ra/386 where:\n    1. path/to/statutes = base_path\n    2. 'ra' is the category\n    3. '386' is the id.\n    \"\"\"\ntarget = base_path / self.cat / self.id\nif target.exists():\nreturn target\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.get_paths","title":"<code>get_paths(base_path=STATUTE_PATH)</code>","text":"<p>The serial id isn't enough in complex statutes.</p> <p>To simplify, imagine Statute A, B and C have the same category and identifier. But refer to different documents.</p> <p>Because of this dilemma, we introduce a digit in the creation of statute folders referring to more than one variant of the intended document.</p> <p>So in the case of <code>/statutes/rule_am/</code>, let's consider <code>00-5-03-sc</code>. This should be valid statute under <code>self.get_path()</code>.</p> <p>However, since there exists 2 variants, we need to rename the original folder to contemplate 2 distinct documents:</p> <ol> <li>statutes/rule_am/00-5-03-sc-1</li> <li>statutes/rule_am/00-5-03-sc-2</li> </ol> <p>Both folders will be retrieved using the plural form of the function <code>self.get_paths()</code></p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def get_paths(self, base_path: Path = STATUTE_PATH) -&gt; list[Path]:\n\"\"\"The serial id isn't enough in complex statutes.\n    To simplify, imagine Statute A, B and C have the same\n    category and identifier. But refer to different documents.\n    Because of this dilemma, we introduce a digit in the creation of statute\n    folders referring to more than one variant of the intended document.\n    So in the case of `/statutes/rule_am/`, let's consider `00-5-03-sc`.\n    This should be valid statute under `self.get_path()`.\n    However, since there exists 2 variants, we need to rename the original\n    folder to contemplate 2 distinct documents:\n    1. statutes/rule_am/00-5-03-sc-1\n    2. statutes/rule_am/00-5-03-sc-2\n    Both folders will be retrieved using the plural form of\n    the function `self.get_paths()`\n    \"\"\"\ntargets = []\ntarget = base_path / self.cat\npaths = target.glob(f\"{self.id}-*/{DETAILS_FILE}\")\nfor variant_path in paths:\nif variant_path.exists():\ntargets.append(variant_path.parent)\nreturn targets\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.units_path","title":"<code>units_path(statute_folder)</code>","text":"<p>There are two kinds of unit files: the preferred / customized variant and the one scraped (the default in the absence of a preferred variant).</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def units_path(self, statute_folder: Path) -&gt; Path | None:\n\"\"\"There are two kinds of unit files: the preferred / customized\n    variant and the one scraped (the default in the absence of a preferred\n    variant).\"\"\"\npreferred = statute_folder / f\"{self.cat}{self.id}.yaml\"\nif preferred.exists():\nreturn preferred\ndefault = statute_folder / \"units.yaml\"\nif default.exists():\nreturn default\nreturn None\n</code></pre>"},{"location":"api-rule/#base-pattern","title":"Base Pattern","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BasePattern(BaseModel, abc.ABC):\nmatches: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should_ match regex property.\",\n)\nexcludes: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should not_ match regex property.\",\n)\nclass Config:\nuse_enum_values = True\ndef __init__(self, **kwargs):\nsuper().__init__(**kwargs)\nself.validate_matches()\nself.validate_excludes()\n@property\n@abc.abstractmethod\ndef regex(self) -&gt; str:\n\"\"\"Combines the group_name with the desired regex string.\"\"\"\nraise NotImplementedError(\n\"Base regex to be later combined with other rules regex strings.\"\n)\n@property\n@abc.abstractmethod\ndef group_name(self) -&gt; str:\n\"\"\"Added to regex string to identify the `match.lastgroup`\"\"\"\nraise NotImplementedError(\"Used to identify `regex` capture group.\")\n@property\ndef pattern(self) -&gt; Pattern:\n\"\"\"Enables use of a unique Pattern object per rule pattern created,\n        regardless of it being a SerialPattern or a NamedPattern.\"\"\"\nreturn re.compile(self.regex, re.X)\ndef validate_matches(self) -&gt; None:\nfor example_text in self.matches:\nif not self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Missing match but intended to be included: {example_text}\"\n)\ndef validate_excludes(self) -&gt; None:\nfor example_text in self.excludes:\nif self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Match found even if intended to be excluded: {example_text}.\"\n)\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.BasePattern-attributes","title":"Attributes","text":""},{"location":"api-rule/#statute_patterns.components.rule.BasePattern.group_name","title":"<code>group_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Added to regex string to identify the <code>match.lastgroup</code></p>"},{"location":"api-rule/#statute_patterns.components.rule.BasePattern.pattern","title":"<code>pattern: Pattern</code>  <code>property</code>","text":"<p>Enables use of a unique Pattern object per rule pattern created, regardless of it being a SerialPattern or a NamedPattern.</p>"},{"location":"api-rule/#statute_patterns.components.rule.BasePattern.regex","title":"<code>regex: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Combines the group_name with the desired regex string.</p>"},{"location":"api-rule/#base-collection","title":"Base Collection","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> <p>Whether a collection of Named or Serial patterns are instantiated, a <code>combined_regex</code> property and a <code>pattern</code> propery will be automatically created based on the collection of objects declared on instantiation of the class.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BaseCollection(BaseModel, abc.ABC):\n\"\"\"Whether a collection of Named or Serial patterns are instantiated,\n    a `combined_regex` property and a `pattern` propery will be automatically\n    created based on the collection of objects declared on instantiation\n    of the class.\"\"\"\ncollection: list = NotImplemented\n@abc.abstractmethod\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\nraise NotImplementedError(\"Need ability to fetch Rule objects.\")\n@property\ndef combined_regex(self) -&gt; str:\n\"\"\"Combine the different items in the collection\n        (having .regex attribute) to form a single regex string.\"\"\"\nreturn \"|\".join([r.regex for r in self.collection])\n@property\ndef pattern(self) -&gt; Pattern:\nreturn re.compile(self.combined_regex, re.X)\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.BaseCollection-attributes","title":"Attributes","text":""},{"location":"api-rule/#statute_patterns.components.rule.BaseCollection.combined_regex","title":"<code>combined_regex: str</code>  <code>property</code>","text":"<p>Combine the different items in the collection (having .regex attribute) to form a single regex string.</p>"},{"location":"api-title/","title":"Title","text":""},{"location":"api-title/#statute-title-category-model","title":"Statute Title Category Model","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Each statute's title can be referred to in various ways.</p> Category Mandatory Nature Description Example <code>official</code> yes official full length title AN ACT TO PROVIDE PROTECTION TO BUYERS OF REAL ESTATE ON INSTALLMENT PAYMENTS <code>serial</code> yes official a <code>StatuteSerialCategory</code> and a serial identifier. Republic Act No. 6552 <code>short</code> no official may be declared in body of statute Realty Installment Buyer Act <code>alias</code> no unofficial popular, undocumented means of referring to a statute Maceda Law Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>class StatuteTitleCategory(str, Enum):\n\"\"\"\n    Each statute's title can be referred to in various ways.\n    Category | Mandatory | Nature | Description | Example\n    --:|:--:|:--:|:--|:--\n    `official` | yes | official | full length title | _AN ACT TO PROVIDE PROTECTION TO BUYERS OF REAL ESTATE ON INSTALLMENT PAYMENTS_\n    `serial` | yes | official | a `StatuteSerialCategory` and a serial identifier. | _Republic Act No. 6552_\n    `short`  | no | official | may be declared in body of statute | _Realty Installment Buyer Act_\n    `alias`  | no | unofficial | popular, undocumented means of referring to a statute | _Maceda Law_\n    \"\"\"\nOfficial = \"official\"\nSerial = \"serial\"\nAlias = \"alias\"\nShort = \"short\"\n</code></pre>"},{"location":"api-title/#statute-category-model","title":"Statute Category Model","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api-title/#statute_patterns.components.category.StatuteSerialCategory--concept","title":"Concept","text":"<p>It would be difficult to identify rules if they were arbitrarily named without a fixed point of reference. For instance the \"Civil Code of the Philippines\",  an arbitrary collection of letters, would be hard to find if laws were organized alphabetically.</p> <p>Fortunately, each Philippine <code>serial</code>-title rule belongs to an assignable <code>StatuteSerialCategory</code>. This is not an official reference but rather a non-exhaustive taxonomy of Philippine legal rules mapped to a <code>enum.Enum</code> object.</p> Enum Purpose <code>name</code> for most members, can \"uncamel\"-ized to produce serial title <code>value</code> (a) folder for discovering path / (b) category usable in the database table <p>Using this model simplifies the ability to navigate rules. Going back to the Civil Code described above, its <code>serial</code> title is Republic Act No. 386 and thus can be mapped to the following folder: <code>/statutes/ra/386</code>. We can definitely categorize this as an ra with a serial id of 386.</p> <p>Mapped to its <code>Rule</code>, counterpart we get:</p> Field Value Description <code>cat</code> ra Serial statute category <code>id</code> 386 Serial identifier of the category"},{"location":"api-title/#statute_patterns.components.category.StatuteSerialCategory--purpose","title":"Purpose","text":"<p>Knowing the path to a rule, we can later extract the rule's contents. (Note however that there can be more than one path since in exceptional cases, the combination of category + serial id does not yield a unique rule.)</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; StatuteSerialCategory\n&lt;enum 'StatuteSerialCategory'&gt;\n&gt;&gt;&gt; StatuteSerialCategory._member_map_\n{'RepublicAct': &lt;StatuteSerialCategory.RepublicAct: 'ra'&gt;, 'CommonwealthAct': &lt;StatuteSerialCategory.CommonwealthAct: 'ca'&gt;, 'Act': &lt;StatuteSerialCategory.Act: 'act'&gt;, 'Constitution': &lt;StatuteSerialCategory.Constitution: 'const'&gt;, 'Spain': &lt;StatuteSerialCategory.Spain: 'spain'&gt;, 'BatasPambansa': &lt;StatuteSerialCategory.BatasPambansa: 'bp'&gt;, 'PresidentialDecree': &lt;StatuteSerialCategory.PresidentialDecree: 'pd'&gt;, 'ExecutiveOrder': &lt;StatuteSerialCategory.ExecutiveOrder: 'eo'&gt;, 'LetterOfInstruction': &lt;StatuteSerialCategory.LetterOfInstruction: 'loi'&gt;, 'VetoMessage': &lt;StatuteSerialCategory.VetoMessage: 'veto'&gt;, 'RulesOfCourt': &lt;StatuteSerialCategory.RulesOfCourt: 'roc'&gt;, 'BarMatter': &lt;StatuteSerialCategory.BarMatter: 'rule_bm'&gt;, 'AdministrativeMatter': &lt;StatuteSerialCategory.AdministrativeMatter: 'rule_am'&gt;, 'ResolutionEnBanc': &lt;StatuteSerialCategory.ResolutionEnBanc: 'rule_reso'&gt;, 'CircularOCA': &lt;StatuteSerialCategory.CircularOCA: 'oca_cir'&gt;, 'CircularSC': &lt;StatuteSerialCategory.CircularSC: 'sc_cir'&gt;}\n</code></pre> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>class StatuteSerialCategory(str, Enum):\n\"\"\"\n    ## Concept\n    It would be difficult to identify rules if they were arbitrarily named\n    without a fixed point of reference. For instance the \"Civil Code of the\n    Philippines\",  an arbitrary collection of letters, would be hard to find\n    if laws were organized alphabetically.\n    Fortunately, each Philippine `serial`-title rule belongs to an\n    assignable `StatuteSerialCategory`. This is not an official reference but\n    rather a non-exhaustive taxonomy of Philippine legal rules mapped to\n    a `enum.Enum` object.\n    Enum | Purpose\n    --:|:--\n    `name` | for _most_ members, can \"uncamel\"-ized to produce serial title\n    `value` | (a) folder for discovering path / (b) category usable in the database table\n    Using this model simplifies the ability to navigate rules. Going back to\n    the Civil Code described above, its `serial` title is _Republic Act No. 386_ and\n    thus can be mapped to the following folder: `/statutes/ra/386`. We can definitely\n    categorize this as an _ra_ with a serial id of _386_.\n    Mapped to its `Rule`, counterpart we get:\n    Field | Value | Description\n    :--:|:--:|:--\n    `cat`| ra | Serial statute category\n    `id` | 386 | Serial identifier of the category\n    ## Purpose\n    Knowing the path to a rule, we can later extract the rule's contents. (Note however that there can be more than one path since in exceptional cases, the combination of *category* + *serial id* does not yield a unique rule.)\n    Examples:\n        &gt;&gt;&gt; StatuteSerialCategory\n        &lt;enum 'StatuteSerialCategory'&gt;\n        &gt;&gt;&gt; StatuteSerialCategory._member_map_\n        {'RepublicAct': &lt;StatuteSerialCategory.RepublicAct: 'ra'&gt;, 'CommonwealthAct': &lt;StatuteSerialCategory.CommonwealthAct: 'ca'&gt;, 'Act': &lt;StatuteSerialCategory.Act: 'act'&gt;, 'Constitution': &lt;StatuteSerialCategory.Constitution: 'const'&gt;, 'Spain': &lt;StatuteSerialCategory.Spain: 'spain'&gt;, 'BatasPambansa': &lt;StatuteSerialCategory.BatasPambansa: 'bp'&gt;, 'PresidentialDecree': &lt;StatuteSerialCategory.PresidentialDecree: 'pd'&gt;, 'ExecutiveOrder': &lt;StatuteSerialCategory.ExecutiveOrder: 'eo'&gt;, 'LetterOfInstruction': &lt;StatuteSerialCategory.LetterOfInstruction: 'loi'&gt;, 'VetoMessage': &lt;StatuteSerialCategory.VetoMessage: 'veto'&gt;, 'RulesOfCourt': &lt;StatuteSerialCategory.RulesOfCourt: 'roc'&gt;, 'BarMatter': &lt;StatuteSerialCategory.BarMatter: 'rule_bm'&gt;, 'AdministrativeMatter': &lt;StatuteSerialCategory.AdministrativeMatter: 'rule_am'&gt;, 'ResolutionEnBanc': &lt;StatuteSerialCategory.ResolutionEnBanc: 'rule_reso'&gt;, 'CircularOCA': &lt;StatuteSerialCategory.CircularOCA: 'oca_cir'&gt;, 'CircularSC': &lt;StatuteSerialCategory.CircularSC: 'sc_cir'&gt;}\n    \"\"\"  # noqa: E501\nRepublicAct = \"ra\"\nCommonwealthAct = \"ca\"\nAct = \"act\"\nConstitution = \"const\"\nSpain = \"spain\"\nBatasPambansa = \"bp\"\nPresidentialDecree = \"pd\"\nExecutiveOrder = \"eo\"\nLetterOfInstruction = \"loi\"\nVetoMessage = \"veto\"\nRulesOfCourt = \"roc\"\nBarMatter = \"rule_bm\"\nAdministrativeMatter = \"rule_am\"\nResolutionEnBanc = \"rule_reso\"\nCircularOCA = \"oca_cir\"\nCircularSC = \"sc_cir\"\ndef serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n        Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n        1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n        2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n        \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"api-title/#statute_patterns.components.category.StatuteSerialCategory-functions","title":"Functions","text":""},{"location":"api-title/#statute_patterns.components.category.StatuteSerialCategory.serialize","title":"<code>serialize(idx)</code>","text":"<p>Given a member item and a valid serialized identifier, create a serial title.</p> <p>Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.</p> <ol> <li><code>pd</code> + <code>570-a</code> = <code>Presidential Decree No. 570-A</code></li> <li><code>rule_am</code> + <code>03-06-13-sc</code> = <code>Administrative Matter No. 03-06-13-SC</code></li> </ol> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>def serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n    Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n    1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n    2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n    \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"api-title/#extract-short-title","title":"Extract Short Title","text":"Source code in <code>statute_patterns/components/short.py</code> Python<pre><code>def get_short(units: list[dict]) -&gt; str | None:\ntry:\nreturn next(find_title(units))\nexcept StopIteration:\nreturn None\n</code></pre>"}]}