{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Summary","text":""},{"location":"#match-titles","title":"Match Titles","text":"<p>Detect titles of Philippine statutes when found in text.</p> Python<pre><code># imagine messy legalese with citations\n&gt;&gt;&gt; text = \"\"\"\nA.M. No. 02-11-10-SC or the Rules on Declaration of Absolute;\nAdministrative Order No. 3 by enacting A.M. No. 99-10-05-0;\nParenthetically, under these statutes [referring to RA Nos. 965 and 2630]\nCommonwealth Act (C.A.) No. 613, otherwise known as\nthe &lt;em&gt;Philippine Immigration Act of 1940&lt;/em&gt;; see also\nRepublic Act No. 386\n\"\"\"\n&gt;&gt;&gt; from statute_patterns import extract_rules\n&gt;&gt;&gt; list(extract_rules(text))\n[Rule(cat='rule_am', id='02-11-10-sc'),\nRule(cat='rule_am', id='99-10-05-0'),\nRule(cat='ra', id='965'),\nRule(cat='ra', id='2630'),\nRule(cat='ca', id='613'),\nRule(cat='ra', id='386')]\n</code></pre>"},{"location":"#extract-content","title":"Extract Content","text":"<p>Generate a path to the title detected and extract its contents. This presumes a structured local path like so:</p> YAML<pre><code>/statutes\n/act # act of congress\n/ca # commonwealth act\n/ra # republic act\n/386 # ra 386 = civil code\ndetails.yaml # contains main file\nunits.yaml (or ra386.yaml) # contains provisions\n</code></pre> <p>The main <code>details.yaml</code> file should contain relevant metadata:</p> YAML<pre><code>numeral: '386' # serial id\ncategory: ra  # category\nlaw_title: An Act to Ordain and Institute the Civil Code of the Philippines # official title\ndate: June 18, 1949\naliases:\n- New Civil Code # maps to alias\n- Civil Code of 1950\nemails:\n- maria@abcxyz.law # email address of formatter\n- fernando@abcxyz.law # can have multiple formatters\n</code></pre> <p>The provisions <code>units.yaml</code> or <code>ra386.yaml</code> file should be properly nested:</p> YAML<pre><code>- item: Container 1\ncaption: Preliminary Title\nunits:\n- item: Chapter 1\ncaption: Effect and Application of Laws\nunits:\n- item: Article 1\ncontent: |\nThis Act shall be known as the \"Civil Code of the Philippines.\" (n)\n- item: Article 2\n...\n</code></pre> <p>With the example above, it's possible to extract the <code>Statute Details</code> of <code>/statutes/ra/386</code>:</p> Python<pre><code>&gt;&gt;&gt;r = Rule(cat='ra', id='386') # assign the Rule to `r`\n&gt;&gt;&gt;r(&lt;path/to/statutes&gt;) # get the base path to `/statutes`\nStatuteDetails(\ncreated=1665225124.0644598,\nmodified=1665225124.0644598,\nrule=Rule(cat='ra', id='386'),\ntitle='Republic Act No. 386',\ndescription='An Act to Ordain and Institute the Civil Code of the Philippines',\nid='ra-386-june-18-1949',\nemails=['maria@abcxyz.law', 'fernando@abcxyz.law'],\ndate=datetime.date(1949, 6, 18),\nvariant=1,\nunits=[\n{\n'item': 'Container 1',\n'caption': 'Preliminary Title',\n'units': [\n{\n'item': 'Chapter 1',\n'caption': 'Effect and Application of Laws',\n'units': [\n{\n'item': 'Article 1',\n'content': 'This Act shall be known as the \"Civil Code of the Philippines.\" (n)\\n'\n},\n{\n'item': 'Article 2',\n'content': 'Laws shall take effect after fifteen days following the completion of their publication either in the Official Gazette or in a newspaper of general circulation in the Philippines, unless it is otherwise provided. (1a)\\n'\n},\n...\n]\n},\n...\n]\n},\n...\n],\ntitles=[\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='alias',\ntext='New Civil Code'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='alias',\ntext='Civil Code of 1950'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='official',\ntext='An Act to Ordain and Institute the Civil Code of the Philippines'\n),\nStatuteTitle(\nstatute_id='ra-386-june-18-1949',\ncategory='serial',\ntext='Republic Act No. 386'\n)\n]\n)\n</code></pre>"},{"location":"api-extract/","title":"Extract","text":"<p>This presumes existence of a local path to a separate library where the contents of the rule can be extracted from.</p>"},{"location":"api-extract/#extract-rules","title":"Extract Rules","text":"<p>If text contains serialized (e.g. Republic Act No. 386) and named rules ('the Civil Code of the Philippines'), get a list of their the canonical <code>Rule</code> version.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from statute_patterns import extract_rules\n&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; list(extract_rules(text)) # get all rules\n[\n    Rule(cat='ra', id='386'),\n    Rule(cat='ra', id='386'),\n    Rule(cat='spain', id='civil')\n]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for statute patterns.</p> required <p>Yields:</p> Type Description <code>Iterator[Rule]</code> <p>Iterator[Rule]: Serialized Rules and Named Rule patterns</p> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def extract_rules(text: str) -&gt; Iterator[Rule]:\n\"\"\"If text contains [serialized][serial-pattern] (e.g. Republic Act No. 386)\n    and [named][named-pattern] rules ('the Civil Code of the Philippines'), get\n    a list of their the canonical [`Rule`][rule-model] version.\n    Examples:\n        &gt;&gt;&gt; from statute_patterns import extract_rules\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; list(extract_rules(text)) # get all rules\n        [\n            Rule(cat='ra', id='386'),\n            Rule(cat='ra', id='386'),\n            Rule(cat='spain', id='civil')\n        ]\n    Args:\n        text (str): Text to search for statute patterns.\n    Yields:\n        Iterator[Rule]: Serialized Rules and Named Rule patterns\n    \"\"\"\nyield from SerializedRules.extract_rules(text)\nyield from NamedRules.extract_rules(text)\n</code></pre>"},{"location":"api-extract/#extract-rule","title":"Extract Rule","text":"<p>Thin wrapper over <code>extract_rules()</code>. If text contains a matching <code>Rule</code>, get the first found.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from statute_patterns import extract_rule\n&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; extract_rule(text)  # get the first matching rule\nRule(cat='ra', id='386')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for statute patterns.</p> required <p>Returns:</p> Type Description <code>Rule | None</code> <p>Rule | None: The first Rule found, if it exists</p> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def extract_rule(text: str) -&gt; Rule | None:\n\"\"\"Thin wrapper over [`extract_rules()`][extract-rules]. If text contains a\n    matching [`Rule`][rule-model], get the first found.\n    Examples:\n        &gt;&gt;&gt; from statute_patterns import extract_rule\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; extract_rule(text)  # get the first matching rule\n        Rule(cat='ra', id='386')\n    Args:\n        text (str): Text to search for statute patterns.\n    Returns:\n        Rule | None: The first Rule found, if it exists\n    \"\"\"\ntry:\nreturn next(extract_rules(text))\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"api-extract/#count-rules","title":"Count Rules","text":"<p>Based on results from <code>extract_rules()</code>, get the count of each unique rule found.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from statute_patterns import count_rules\n&gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n&gt;&gt;&gt; list(count_rules(text)): # get unique rules with counts\n[\n    {'cat': 'ra', 'id': '386', 'mentions': 2},\n    {'cat': 'spain', 'id': 'civil', 'mentions': 1}\n]\n</code></pre> Source code in <code>statute_patterns/__main__.py</code> Python<pre><code>def count_rules(text: str) -&gt; Iterator[dict]:\n\"\"\"Based on results from [`extract_rules()`][extract-rules],\n    get the count of each unique rule found.\n    Examples:\n        &gt;&gt;&gt; from statute_patterns import count_rules\n        &gt;&gt;&gt; text = \"The Civil Code of the Philippines, the old Spanish Civil Code; Rep Act No. 386\"\n        &gt;&gt;&gt; list(count_rules(text)): # get unique rules with counts\n        [\n            {'cat': 'ra', 'id': '386', 'mentions': 2},\n            {'cat': 'spain', 'id': 'civil', 'mentions': 1}\n        ]\n    \"\"\"\nfor k, v in Counter(extract_rules(text)).items():\nyield k.dict() | {\"mentions\": v}\n</code></pre>"},{"location":"api-extract/#detail-rule","title":"Detail Rule","text":"<p>We can extract the details of the rule with the <code>StatuteDetails.from_rule()</code> also accessible via <code>Rule.get_details()</code>.</p>"},{"location":"api-extract/#statutedetails","title":"StatuteDetails","text":"<p>         Bases: <code>BaseModel</code></p> <p>A <code>StatuteDetails</code> object presupposes the existence of a <code>Rule</code> object.</p> <p>After all, it's only when there's a valid path to a <code>Rule</code> that the details and provisions of that rule can be extracted. Some notable fields are described below:</p> Field Type Function rule <code>Rule</code> How we source the path title str The statute's serial title, e.g. Republic Act No. 386 description str The statute's official title, e.g. An Act to... Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>class StatuteDetails(BaseModel):\n\"\"\"\n    A `StatuteDetails` object presupposes the existence of a [`Rule`][rule-model] object.\n    After all, it's only when there's a valid path to a [`Rule`][rule-model] that the details\n    and provisions of that rule can be extracted. Some notable fields\n    are described below:\n    Field | Type | Function\n    :--:|:--:|:--:\n    rule | [`Rule`][rule-model] | How we source the path\n    title | str | The statute's serial title, e.g. Republic Act No. 386\n    description | str | The statute's official title, e.g. An Act to...\n    \"\"\"\ncreated: float\nmodified: float\nrule: Rule\ntitle: str\ndescription: str\nid: str\nemails: list[EmailStr]\ndate: datetime.date\nvariant: int\ntitles: list[StatuteTitle]\nunits: list[dict]\n@classmethod\ndef slug_id(cls, p: Path, dt: str, v: int | None):\n\"\"\"Use the path's parameters with the date and variant, to\n        create a slug that can serve as the url / primary key of the\n        statute.\"\"\"\n_temp = [p.parent.parent.stem, p.parent.stem, dt]\nif v:\n_temp.append(str(v))\nreturn slugify(\" \".join(_temp))\n@classmethod\ndef from_rule(cls, rule: Rule, base_path: Path = STATUTE_PATH):\n\"\"\"From a constructed rule (see [`Rule.from_path`][statute_patterns.components.rule.Rule.from_path]), get the\n        details of said rule.  Limitation: the category and identifier must\n        be unique.\"\"\"\nif not base_path.exists():\nraise Exception(f\"Could not get proper {base_path=}.\")\nif not rule.serial_title:\nraise Exception(\"No serial title created.\")\n_file = None\nif folder := rule.get_path(base_path):\n_file = folder / DETAILS_FILE\nif not _file or not _file.exists():\nraise Exception(f\"No _file found from {folder=} {base_path=}.\")\nd = yaml.safe_load(_file.read_bytes())\ndt, ofc_title, v = d.get(\"date\"), d.get(\"law_title\"), d.get(\"variant\")\nif not all([ofc_title, dt]):\nraise Exception(f\"Fail on: {dt=}, {ofc_title=}, {v=}\")\nunits = set_units(ofc_title, rule.units_path(_file.parent))\nidx = cls.slug_id(_file, dt, v)\ntitles = StatuteTitle.generate(\npk=idx,\nofficial=ofc_title,\nserial=rule.serial_title,\nshort=get_short(units),\naliases=d.get(\"aliases\"),\n)\nreturn cls(\ncreated=_file.stat().st_ctime,\nmodified=_file.stat().st_mtime,\nrule=rule,\nid=idx,\ntitle=rule.serial_title,\ndescription=ofc_title,\nemails=d.get(\"emails\", [\"bot@lawsql.com\"]),  # default to generic\ndate=parse(d[\"date\"]).date(),\nvariant=v or 1,  # default to 1\nunits=units,\ntitles=list(titles),\n)\n</code></pre>"},{"location":"api-extract/#statute_patterns.components.details.StatuteDetails-functions","title":"Functions","text":""},{"location":"api-extract/#statute_patterns.components.details.StatuteDetails.from_rule","title":"<code>from_rule(rule, base_path=STATUTE_PATH)</code>  <code>classmethod</code>","text":"<p>From a constructed rule (see <code>Rule.from_path</code>), get the details of said rule.  Limitation: the category and identifier must be unique.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>@classmethod\ndef from_rule(cls, rule: Rule, base_path: Path = STATUTE_PATH):\n\"\"\"From a constructed rule (see [`Rule.from_path`][statute_patterns.components.rule.Rule.from_path]), get the\n    details of said rule.  Limitation: the category and identifier must\n    be unique.\"\"\"\nif not base_path.exists():\nraise Exception(f\"Could not get proper {base_path=}.\")\nif not rule.serial_title:\nraise Exception(\"No serial title created.\")\n_file = None\nif folder := rule.get_path(base_path):\n_file = folder / DETAILS_FILE\nif not _file or not _file.exists():\nraise Exception(f\"No _file found from {folder=} {base_path=}.\")\nd = yaml.safe_load(_file.read_bytes())\ndt, ofc_title, v = d.get(\"date\"), d.get(\"law_title\"), d.get(\"variant\")\nif not all([ofc_title, dt]):\nraise Exception(f\"Fail on: {dt=}, {ofc_title=}, {v=}\")\nunits = set_units(ofc_title, rule.units_path(_file.parent))\nidx = cls.slug_id(_file, dt, v)\ntitles = StatuteTitle.generate(\npk=idx,\nofficial=ofc_title,\nserial=rule.serial_title,\nshort=get_short(units),\naliases=d.get(\"aliases\"),\n)\nreturn cls(\ncreated=_file.stat().st_ctime,\nmodified=_file.stat().st_mtime,\nrule=rule,\nid=idx,\ntitle=rule.serial_title,\ndescription=ofc_title,\nemails=d.get(\"emails\", [\"bot@lawsql.com\"]),  # default to generic\ndate=parse(d[\"date\"]).date(),\nvariant=v or 1,  # default to 1\nunits=units,\ntitles=list(titles),\n)\n</code></pre>"},{"location":"api-extract/#statute_patterns.components.details.StatuteDetails.slug_id","title":"<code>slug_id(p, dt, v)</code>  <code>classmethod</code>","text":"<p>Use the path's parameters with the date and variant, to create a slug that can serve as the url / primary key of the statute.</p> Source code in <code>statute_patterns/components/details.py</code> Python<pre><code>@classmethod\ndef slug_id(cls, p: Path, dt: str, v: int | None):\n\"\"\"Use the path's parameters with the date and variant, to\n    create a slug that can serve as the url / primary key of the\n    statute.\"\"\"\n_temp = [p.parent.parent.stem, p.parent.stem, dt]\nif v:\n_temp.append(str(v))\nreturn slugify(\" \".join(_temp))\n</code></pre>"},{"location":"api-match/","title":"Match","text":""},{"location":"api-match/#statute-title-category-model","title":"Statute Title Category Model","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Each statute's title can be referred to in various ways.</p> Category Mandatory Nature Description Example <code>official</code> yes official full length title AN ACT TO PROVIDE PROTECTION TO BUYERS OF REAL ESTATE ON INSTALLMENT PAYMENTS <code>serial</code> yes official <code>Statute Category</code> + serial identifier. Republic Act No. 6552 <code>short</code> no official may be declared in body of statute Realty Installment Buyer Act <code>alias</code> no unofficial popular, undocumented means of referring to a statute Maceda Law Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>class StatuteTitleCategory(str, Enum):\n\"\"\"\n    Each statute's title can be referred to in various ways.\n    Category | Mandatory | Nature | Description | Example\n    --:|:--:|:--:|:--|:--\n    `official` | yes | official | full length title | _AN ACT TO PROVIDE PROTECTION TO BUYERS OF REAL ESTATE ON INSTALLMENT PAYMENTS_\n    `serial` | yes | official | [`Statute Category`][statute-category-model] + serial identifier. | _Republic Act No. 6552_\n    `short`  | no | official | may be declared in body of statute | _Realty Installment Buyer Act_\n    `alias`  | no | unofficial | popular, undocumented means of referring to a statute | _Maceda Law_\n    \"\"\"\nOfficial = \"official\"\nSerial = \"serial\"\nAlias = \"alias\"\nShort = \"short\"\n</code></pre>"},{"location":"api-match/#statute-category-model","title":"Statute Category Model","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api-match/#statute_patterns.components.category.StatuteSerialCategory--concept","title":"Concept","text":"<p>It would be difficult to identify rules if they were arbitrarily named without a fixed point of reference. For instance the \"Civil Code of the Philippines\",  an arbitrary collection of letters, would be hard to find if laws were organized alphabetically.</p> <p>Fortunately, each Philippine <code>serial</code>-title rule belongs to an assignable <code>StatuteSerialCategory</code>. This is not an official reference but rather a non-exhaustive taxonomy of Philippine legal rules mapped to a <code>enum.Enum</code> object.</p> Enum Purpose <code>name</code> for most members, can \"uncamel\"-ized to produce serial title <code>value</code> (a) folder for discovering path / (b) category usable in the database table <p>Using this model simplifies the ability to navigate rules. Going back to the Civil Code described above, its <code>serial</code> title is Republic Act No. 386 and thus can be mapped to the following folder: <code>/statutes/ra/386</code>. We can definitely categorize this as an ra with a serial id of 386.</p> <p>Mapped to its <code>Rule</code> counterpart we get:</p> Field Value Description <code>cat</code> ra Serial statute category <code>id</code> 386 Serial identifier of the category"},{"location":"api-match/#statute_patterns.components.category.StatuteSerialCategory--purpose","title":"Purpose","text":"<p>Knowing the path to a rule, we can later extract the rule's contents. (Note however that there can be more than one path since in exceptional cases, the combination of category + serial id does not yield a unique rule.)</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; StatuteSerialCategory\n&lt;enum 'StatuteSerialCategory'&gt;\n&gt;&gt;&gt; StatuteSerialCategory._member_map_\n{'RepublicAct': &lt;StatuteSerialCategory.RepublicAct: 'ra'&gt;, 'CommonwealthAct': &lt;StatuteSerialCategory.CommonwealthAct: 'ca'&gt;, 'Act': &lt;StatuteSerialCategory.Act: 'act'&gt;, 'Constitution': &lt;StatuteSerialCategory.Constitution: 'const'&gt;, 'Spain': &lt;StatuteSerialCategory.Spain: 'spain'&gt;, 'BatasPambansa': &lt;StatuteSerialCategory.BatasPambansa: 'bp'&gt;, 'PresidentialDecree': &lt;StatuteSerialCategory.PresidentialDecree: 'pd'&gt;, 'ExecutiveOrder': &lt;StatuteSerialCategory.ExecutiveOrder: 'eo'&gt;, 'LetterOfInstruction': &lt;StatuteSerialCategory.LetterOfInstruction: 'loi'&gt;, 'VetoMessage': &lt;StatuteSerialCategory.VetoMessage: 'veto'&gt;, 'RulesOfCourt': &lt;StatuteSerialCategory.RulesOfCourt: 'roc'&gt;, 'BarMatter': &lt;StatuteSerialCategory.BarMatter: 'rule_bm'&gt;, 'AdministrativeMatter': &lt;StatuteSerialCategory.AdministrativeMatter: 'rule_am'&gt;, 'ResolutionEnBanc': &lt;StatuteSerialCategory.ResolutionEnBanc: 'rule_reso'&gt;, 'CircularOCA': &lt;StatuteSerialCategory.CircularOCA: 'oca_cir'&gt;, 'CircularSC': &lt;StatuteSerialCategory.CircularSC: 'sc_cir'&gt;}\n</code></pre> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>class StatuteSerialCategory(str, Enum):\n\"\"\"\n    ## Concept\n    It would be difficult to identify rules if they were arbitrarily named\n    without a fixed point of reference. For instance the \"Civil Code of the\n    Philippines\",  an arbitrary collection of letters, would be hard to find\n    if laws were organized alphabetically.\n    Fortunately, each Philippine `serial`-title rule belongs to an\n    assignable `StatuteSerialCategory`. This is not an official reference but\n    rather a non-exhaustive taxonomy of Philippine legal rules mapped to\n    a `enum.Enum` object.\n    Enum | Purpose\n    --:|:--\n    `name` | for _most_ members, can \"uncamel\"-ized to produce serial title\n    `value` | (a) folder for discovering path / (b) category usable in the database table\n    Using this model simplifies the ability to navigate rules. Going back to\n    the Civil Code described above, its `serial` title is _Republic Act No. 386_ and\n    thus can be mapped to the following folder: `/statutes/ra/386`. We can definitely\n    categorize this as an _ra_ with a serial id of _386_.\n    Mapped to its [`Rule`][rule-model] counterpart we get:\n    Field | Value | Description\n    :--:|:--:|:--\n    `cat`| ra | Serial statute category\n    `id` | 386 | Serial identifier of the category\n    ## Purpose\n    Knowing the path to a rule, we can later extract the rule's contents. (Note however that there can be more than one path since in exceptional cases, the combination of *category* + *serial id* [does not yield a unique rule][statute_patterns.components.rule.Rule.get_paths].)\n    Examples:\n        &gt;&gt;&gt; StatuteSerialCategory\n        &lt;enum 'StatuteSerialCategory'&gt;\n        &gt;&gt;&gt; StatuteSerialCategory._member_map_\n        {'RepublicAct': &lt;StatuteSerialCategory.RepublicAct: 'ra'&gt;, 'CommonwealthAct': &lt;StatuteSerialCategory.CommonwealthAct: 'ca'&gt;, 'Act': &lt;StatuteSerialCategory.Act: 'act'&gt;, 'Constitution': &lt;StatuteSerialCategory.Constitution: 'const'&gt;, 'Spain': &lt;StatuteSerialCategory.Spain: 'spain'&gt;, 'BatasPambansa': &lt;StatuteSerialCategory.BatasPambansa: 'bp'&gt;, 'PresidentialDecree': &lt;StatuteSerialCategory.PresidentialDecree: 'pd'&gt;, 'ExecutiveOrder': &lt;StatuteSerialCategory.ExecutiveOrder: 'eo'&gt;, 'LetterOfInstruction': &lt;StatuteSerialCategory.LetterOfInstruction: 'loi'&gt;, 'VetoMessage': &lt;StatuteSerialCategory.VetoMessage: 'veto'&gt;, 'RulesOfCourt': &lt;StatuteSerialCategory.RulesOfCourt: 'roc'&gt;, 'BarMatter': &lt;StatuteSerialCategory.BarMatter: 'rule_bm'&gt;, 'AdministrativeMatter': &lt;StatuteSerialCategory.AdministrativeMatter: 'rule_am'&gt;, 'ResolutionEnBanc': &lt;StatuteSerialCategory.ResolutionEnBanc: 'rule_reso'&gt;, 'CircularOCA': &lt;StatuteSerialCategory.CircularOCA: 'oca_cir'&gt;, 'CircularSC': &lt;StatuteSerialCategory.CircularSC: 'sc_cir'&gt;}\n    \"\"\"  # noqa: E501\nRepublicAct = \"ra\"\nCommonwealthAct = \"ca\"\nAct = \"act\"\nConstitution = \"const\"\nSpain = \"spain\"\nBatasPambansa = \"bp\"\nPresidentialDecree = \"pd\"\nExecutiveOrder = \"eo\"\nLetterOfInstruction = \"loi\"\nVetoMessage = \"veto\"\nRulesOfCourt = \"roc\"\nBarMatter = \"rule_bm\"\nAdministrativeMatter = \"rule_am\"\nResolutionEnBanc = \"rule_reso\"\nCircularOCA = \"oca_cir\"\nCircularSC = \"sc_cir\"\ndef serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n        Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n        1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n        2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n        \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"api-match/#statute_patterns.components.category.StatuteSerialCategory-functions","title":"Functions","text":""},{"location":"api-match/#statute_patterns.components.category.StatuteSerialCategory.serialize","title":"<code>serialize(idx)</code>","text":"<p>Given a member item and a valid serialized identifier, create a serial title.</p> <p>Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.</p> <ol> <li><code>pd</code> + <code>570-a</code> = <code>Presidential Decree No. 570-A</code></li> <li><code>rule_am</code> + <code>03-06-13-sc</code> = <code>Administrative Matter No. 03-06-13-SC</code></li> </ol> Source code in <code>statute_patterns/components/category.py</code> Python<pre><code>def serialize(self, idx: str):\n\"\"\"Given a member item and a valid serialized identifier, create a serial title.\n    Note that the identifier must be upper-cased to make this consistent with the textual convention, e.g.\n    1. `pd` + `570-a` = `Presidential Decree No. 570-A`\n    2. `rule_am` + `03-06-13-sc` = `Administrative Matter No. 03-06-13-SC`\n    \"\"\"\ndef uncamel(cat: StatuteSerialCategory):\n\"\"\"See https://stackoverflow.com/a/9283563\"\"\"\nx = r\"((?&lt;=[a-z])[A-Z]|(?&lt;!\\A)[A-Z](?=[a-z]))\"\nreturn re.sub(x, r\" \\1\", cat.name)\nmatch self:  # noqa: E999 TODO: fix\ncase StatuteSerialCategory.Spain:\nsmall_idx = idx.lower()\nif small_idx in [\"civil\", \"penal\"]:\nreturn f\"Spanish {idx.title()} Code\"\nelif small_idx == \"commerce\":\nreturn \"Code of Commerce\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.Constitution:\nif idx.isdigit() and int(idx) in [1935, 1973, 1987]:\nreturn f\"{idx} Constitution\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.RulesOfCourt:\nif idx in [\"1940\", \"1964\"]:\nreturn f\"{idx} Rules of Court\"\nelif idx in [\"cpr\"]:\nreturn \"Code of Professional Responsibility\"\nraise SyntaxWarning(f\"{idx=} invalid serial of {self}\")\ncase StatuteSerialCategory.VetoMessage:\n\"\"\"No need to specify No.; understood to mean a Republic Act\"\"\"\nreturn f\"Veto Message - {idx}\"\ncase StatuteSerialCategory.ResolutionEnBanc:\n\"\"\"The `idx` needs to be a specific itemized date.\"\"\"\nreturn f\"Resolution of the Court En Banc dated {idx}\"\ncase StatuteSerialCategory.CircularSC:\nreturn f\"SC Circular No. {idx}\"\ncase StatuteSerialCategory.CircularOCA:\nreturn f\"OCA Circular No. {idx}\"\ncase StatuteSerialCategory.AdministrativeMatter:\n\"\"\"Handle special rule with variants: e.g.`rule_am 00-5-03-sc-1` and `rule_am 00-5-03-sc-2`\"\"\"\nam = uncamel(self)\nsmall_idx = idx.lower()\nif \"sc\" in small_idx:\nif small_idx.endswith(\"sc\"):\nreturn f\"{am} No. {small_idx.upper()}\"\nelif sans_var := re.search(r\"^.*-sc(?=-\\d+)\", small_idx):\nreturn f\"{am} No. {sans_var.group().upper()}\"\nreturn f\"{am} No. {small_idx.upper()}\"\ncase StatuteSerialCategory.BatasPambansa:\nif idx.isdigit():\nreturn f\"{uncamel(self)} Blg. {idx}\"  # there are no -A -B suffixes in BPs\ncase _:\n# no need to uppercase pure digits\ntarget_digit = idx if idx.isdigit() else idx.upper()\nreturn f\"{uncamel(self)} No. {target_digit}\"\n</code></pre>"},{"location":"api-match/#statute-serial-identifier","title":"Statute Serial Identifier","text":""},{"location":"api-match/#republic-acts","title":"Republic Acts","text":"<p>Criteria:</p> <ol> <li>Numbers should not start with 0</li> <li>Numbers should not exceed 5 digits</li> <li>Although at time of writing max RA is 11xxx (5 digits), added allowance for this to start with 2xxxx (still 5 digits)</li> </ol>"},{"location":"api-match/#commonwealth-acts","title":"Commonwealth Acts","text":"<p>Criteria:</p> <ol> <li>Numbers should not start with 0</li> <li>Numbers should not exceed 3 digits</li> <li>There are 733 Commonwealth Acts numbered sequentially</li> </ol>"},{"location":"api-match/#acts-of-congress","title":"Acts of Congress","text":"<p>Criteria:</p> <ol> <li>Numbers should not start with 0</li> <li>Numbers should not exceed 4 digits</li> <li>There are 4275 Acts of Congress numbered sequentially</li> </ol>"},{"location":"api-match/#batas-pambansa","title":"Batas Pambansa","text":"<p>Criteria:</p> <ol> <li>Numbers should not start with 0</li> <li>Numbers should not exceed 3 digits</li> <li>There are 889 Batas Pambansa</li> </ol>"},{"location":"api-match/#presidential-decrees","title":"Presidential Decrees","text":"<p>Criteria:</p> <ol> <li>Numbers should not start with 0</li> <li>Numbers should not exceed 4 digits but see exceptional suffixes</li> <li>There are 2036 Presidential Decrees</li> </ol>"},{"location":"api-match/#extract-short-title","title":"Extract Short Title","text":"Source code in <code>statute_patterns/components/short.py</code> Python<pre><code>def get_short(units: list[dict]) -&gt; str | None:\ntry:\nreturn next(find_title(units))\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"api-rule-base/","title":"Abstract Rules","text":""},{"location":"api-rule-base/#base-pattern","title":"Base Pattern","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BasePattern(BaseModel, abc.ABC):\nmatches: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should_ match regex property.\",\n)\nexcludes: list[str] = Field(\ndefault_factory=list,\ndescription=\"When supplied, text included _should not_ match regex property.\",\n)\nclass Config:\nuse_enum_values = True\ndef __init__(self, **kwargs):\nsuper().__init__(**kwargs)\nself.validate_matches()\nself.validate_excludes()\n@property\n@abc.abstractmethod\ndef regex(self) -&gt; str:\n\"\"\"Combines the group_name with the desired regex string.\"\"\"\nraise NotImplementedError(\n\"Base regex to be later combined with other rules regex strings.\"\n)\n@property\n@abc.abstractmethod\ndef group_name(self) -&gt; str:\n\"\"\"Added to regex string to identify the `match.lastgroup`\"\"\"\nraise NotImplementedError(\"Used to identify `regex` capture group.\")\n@property\ndef pattern(self) -&gt; Pattern:\n\"\"\"Enables use of a unique Pattern object per rule pattern created,\n        regardless of it being a SerialPattern or a NamedPattern.\"\"\"\nreturn re.compile(self.regex, re.X)\ndef validate_matches(self) -&gt; None:\nfor example_text in self.matches:\nif not self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Missing match but intended to be included: {example_text}\"\n)\ndef validate_excludes(self) -&gt; None:\nfor example_text in self.excludes:\nif self.pattern.fullmatch(example_text):\nraise ValueError(\nf\"Match found even if intended to be excluded: {example_text}.\"\n)\n</code></pre>"},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern-attributes","title":"Attributes","text":""},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern.group_name","title":"<code>group_name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Added to regex string to identify the <code>match.lastgroup</code></p>"},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern.pattern","title":"<code>pattern: Pattern</code>  <code>property</code>","text":"<p>Enables use of a unique Pattern object per rule pattern created, regardless of it being a SerialPattern or a NamedPattern.</p>"},{"location":"api-rule-base/#statute_patterns.components.rule.BasePattern.regex","title":"<code>regex: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Combines the group_name with the desired regex string.</p>"},{"location":"api-rule-base/#base-collection","title":"Base Collection","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> <p>Whether a collection of Named or Serial patterns are instantiated, a <code>combined_regex</code> property and a <code>pattern</code> propery will be automatically created based on the collection of objects declared on instantiation of the class.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class BaseCollection(BaseModel, abc.ABC):\n\"\"\"Whether a collection of Named or Serial patterns are instantiated,\n    a `combined_regex` property and a `pattern` propery will be automatically\n    created based on the collection of objects declared on instantiation\n    of the class.\"\"\"\ncollection: list = NotImplemented\n@abc.abstractmethod\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\nraise NotImplementedError(\"Need ability to fetch Rule objects.\")\n@property\ndef combined_regex(self) -&gt; str:\n\"\"\"Combine the different items in the collection\n        (having .regex attribute) to form a single regex string.\"\"\"\nreturn \"|\".join([r.regex for r in self.collection])\n@property\ndef pattern(self) -&gt; Pattern:\nreturn re.compile(self.combined_regex, re.X)\n</code></pre>"},{"location":"api-rule-base/#statute_patterns.components.rule.BaseCollection-attributes","title":"Attributes","text":""},{"location":"api-rule-base/#statute_patterns.components.rule.BaseCollection.combined_regex","title":"<code>combined_regex: str</code>  <code>property</code>","text":"<p>Combine the different items in the collection (having .regex attribute) to form a single regex string.</p>"},{"location":"api-rule-named/","title":"Named Statutes","text":""},{"location":"api-rule-named/#named-pattern","title":"Named Pattern","text":"<p>         Bases: <code>BasePattern</code></p> <p>A <code>Rule</code> can be extracted from a <code>NamedPattern</code></p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class NamedPattern(BasePattern):\n\"\"\"A [`Rule`][rule-model] can be extracted from a `NamedPattern`\"\"\"\nname: str\nregex_base: str\nrule: Rule\n@property\ndef regex(self) -&gt; str:\nreturn stx(rf\"(?P&lt;{self.group_name}&gt;{self.regex_base})\")\n@property\ndef group_name(self) -&gt; str:\ntexts = \" \".join([self.rule.cat, self.rule.id])\nreturn slugify(texts, separator=\"_\", lowercase=True)\n</code></pre>"},{"location":"api-rule-named/#named-statute-collection","title":"Named Statute Collection","text":"<p>         Bases: <code>BaseCollection</code></p> <p>Each named legal title, not falling under the SerialNames Patterns, will also have its own manually crafted regex string. Examples include 'the Spanish Civil Code' or the '1987 Constitution' or the 'Code of Professional Responsibility'.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class NamedPatternCollection(BaseCollection):\n\"\"\"Each named legal title, not falling under the SerialNames Patterns,\n    will also have its own manually crafted regex string. Examples include\n    'the Spanish Civil Code' or the '1987 Constitution' or the\n    'Code of Professional Responsibility'.\n    \"\"\"\ncollection: list[NamedPattern]\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\nfor m in self.pattern.finditer(text):\nfor named in self.collection:\nif m.lastgroup == named.group_name:\nyield named.rule\n</code></pre>"},{"location":"api-rule-serial/","title":"Serialized Statutes","text":""},{"location":"api-rule-serial/#serial-pattern","title":"Serial Pattern","text":"<p>         Bases: <code>BasePattern</code></p> <p>A <code>Rule</code> can be extracted from a <code>SerialPattern</code>. The word serial is employed because the documents representing rules are numbered consecutively.</p> <p>Each serial pattern refers to a <code>Statute Category</code>, e.g. <code>RA</code>, <code>CA</code>, etc. matched with a <code>Serial Identifier</code>.</p> <p>Since a <code>SerialPattern</code> inherits from a BasePattern, it includes other fields declared in the latter model: <code>matches</code> and <code>excludes</code> bringing the total number of fields to 5, viz.:</p> Field Description Example <code>cat</code> <code>Statute Category</code> StatuteSerialCategory.RepublicAct <code>regex_bases</code> How do we pattern the category name? [\"r.a. no.\", \"Rep. Act. No.\"] <code>regex_serials</code> What digits are allowed [\"386\", \"11114\"] <code>matches</code> Usable in parametized tests to determine whether the pattern declared matches the samples [\"Republic Act No. 7160\", \"R.A. 386 and 7160\" ] <code>excludes</code> Usable in parametized tests to determine that the full pattern will not match [\"Republic Act No. 7160:\", \"RA 9337-\"] Source code in <code>statute_patterns/models.py</code> Python<pre><code>class SerialPattern(BasePattern):\n\"\"\"A [`Rule`][rule-model] can be extracted from a `SerialPattern`. The word _serial_\n    is employed because the documents representing rules are numbered consecutively.\n    Each serial pattern refers to a [`Statute Category`][statute-category-model], e.g. `RA`, `CA`, etc.\n    matched with a [`Serial Identifier`][statute-serial-identifier].\n    Since a `SerialPattern` inherits from a [BasePattern][base-pattern], it includes other\n    fields declared in the latter model: `matches` and `excludes` bringing the\n    total number of fields to 5, viz.:\n    Field | Description | Example\n    --:|:--|:--\n    `cat` | [`Statute Category`][statute-category-model] | StatuteSerialCategory.RepublicAct\n    `regex_bases` | How do we pattern the category name? | [\"r.a. no.\", \"Rep. Act. No.\"]\n    `regex_serials` | What digits are allowed | [\"386\", \"11114\"]\n    `matches` | Usable in parametized tests to determine whether the pattern declared matches the samples | [\"Republic Act No. 7160\", \"R.A. 386 and 7160\" ]\n    `excludes` | Usable in parametized tests to determine that the full pattern will not match | [\"Republic Act No. 7160:\", \"RA 9337-\"]\n    \"\"\"\ncat: StatuteSerialCategory = Field(\n...,\ntitle=\"Statute Serial Category\",\ndescription=\"A type of rule from the taxonomy enumerated under StatuteSerialCategory.\",\n)\nregex_bases: list[str] = Field(\n...,\ntitle=\"Prefix Label in Regex\",\ndescription=\"There are too many ways to express a category name. There is a need to generate various regex strings which, when combined with the serial, can qualify for a serial rule.\",\n)\nregex_serials: list[str] = Field(\n...,\ntitle=\"Serial Identifiers in Regex\",\ndescription=\"The possible values of serial numbers to be matched with the regex_bases.\",\n)\n@property\ndef lines(self) -&gt; Iterator[str]:\n\"\"\"Each regex string produced matches the serial rule. Note the line break\n        needs to be retained so that when printing `@regex`, the result is organized.\n        \"\"\"\nfor base in self.regex_bases:\nfor idx in self.regex_serials:\nyield rf\"\"\"({base}\\s*{idx})\n                \"\"\"\n@property\ndef group_name(self) -&gt; str:\nreturn rf\"serial_{self.cat}\"\n@property\ndef regex(self) -&gt; str:\nreturn rf\"(?P&lt;{self.group_name}&gt;{r'|'.join(self.lines)})\"\n@property\ndef digits_in_match(self) -&gt; Pattern:\nreturn re.compile(r\"|\".join(self.regex_serials))\n</code></pre>"},{"location":"api-rule-serial/#statute_patterns.models.SerialPattern-attributes","title":"Attributes","text":""},{"location":"api-rule-serial/#statute_patterns.models.SerialPattern.lines","title":"<code>lines: Iterator[str]</code>  <code>property</code>","text":"<p>Each regex string produced matches the serial rule. Note the line break needs to be retained so that when printing <code>@regex</code>, the result is organized.</p>"},{"location":"api-rule-serial/#serial-pattern-collection","title":"Serial Pattern Collection","text":"<p>         Bases: <code>BaseCollection</code></p> <p>Each category-based, serial-numbered, legal title will have a regex string, e.g. Republic Act is a category, a serial number for this category is 386 representing the Philippine Civil Code.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>class SerialPatternCollection(BaseCollection):\n\"\"\"Each category-based, serial-numbered, legal title will have a\n    regex string, e.g. Republic Act is a category, a serial number for\n    this category is 386 representing the Philippine Civil Code.\"\"\"\ncollection: list[SerialPattern]\ndef extract_rules(self, text: str) -&gt; Iterator[Rule]:\n\"\"\"Each `m`, a python Match object, represents a\n        serial pattern category with possible ambiguous identifier found.\n        So running `m.group(0)` should yield the entire text of the\n        match which consists of (a) the definitive category;\n        and (b) the ambiguous identifier.\n        The identifier is ambiguous because it may be a compound one,\n        e.g. 'Presidential Decree No. 1 and 2'. In this case, there\n        should be 2 matches produced not just one.\n        This function splits the identifier by commas `,` and the\n        word `and` to get the individual component identifiers.\n        \"\"\"\nfor match in self.pattern.finditer(text):\nfor sp in self.collection:\nif match.lastgroup == sp.group_name:\nif candidates := sp.digits_in_match.search(match.group(0)):\nfor d in split_digits(candidates.group(0)):\nc = sp.cat\nyield Rule(cat=c, id=d)\n</code></pre>"},{"location":"api-rule-serial/#statute_patterns.models.SerialPatternCollection-functions","title":"Functions","text":""},{"location":"api-rule-serial/#statute_patterns.models.SerialPatternCollection.extract_rules","title":"<code>extract_rules(text)</code>","text":"<p>Each <code>m</code>, a python Match object, represents a serial pattern category with possible ambiguous identifier found.</p> <p>So running <code>m.group(0)</code> should yield the entire text of the match which consists of (a) the definitive category; and (b) the ambiguous identifier.</p> <p>The identifier is ambiguous because it may be a compound one, e.g. 'Presidential Decree No. 1 and 2'. In this case, there should be 2 matches produced not just one.</p> <p>This function splits the identifier by commas <code>,</code> and the word <code>and</code> to get the individual component identifiers.</p> Source code in <code>statute_patterns/models.py</code> Python<pre><code>def extract_rules(self, text: str) -&gt; Iterator[Rule]:\n\"\"\"Each `m`, a python Match object, represents a\n    serial pattern category with possible ambiguous identifier found.\n    So running `m.group(0)` should yield the entire text of the\n    match which consists of (a) the definitive category;\n    and (b) the ambiguous identifier.\n    The identifier is ambiguous because it may be a compound one,\n    e.g. 'Presidential Decree No. 1 and 2'. In this case, there\n    should be 2 matches produced not just one.\n    This function splits the identifier by commas `,` and the\n    word `and` to get the individual component identifiers.\n    \"\"\"\nfor match in self.pattern.finditer(text):\nfor sp in self.collection:\nif match.lastgroup == sp.group_name:\nif candidates := sp.digits_in_match.search(match.group(0)):\nfor d in split_digits(candidates.group(0)):\nc = sp.cat\nyield Rule(cat=c, id=d)\n</code></pre>"},{"location":"api-rule/","title":"Rule Model","text":"<p>         Bases: <code>BaseModel</code></p> <p>A <code>Rule</code> is detected if it matches either:</p> <ol> <li><code>Named Patterns</code> or</li> <li><code>Serial Patterns</code></li> </ol> <p>Each rule implies:</p> <ol> <li>Previous validation via regex strings</li> <li>Path to an intended local directory</li> <li>Extractable content</li> <li>Serial title generated by <code>StatuteSerialCategory.serialize()</code></li> <li>Countability via a <code>collection.Counter</code> built-in.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>cat</code> <p>StatuteSerialCategory</p> required <code>id</code> <p>str</p> required Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>class Rule(BaseModel):\n\"\"\"A `Rule` is detected if it matches either:\n    1. [`Named Patterns`][named-pattern] or\n    2. [`Serial Patterns`][serial-pattern]\n    Each rule implies:\n    1. Previous validation via regex strings\n    2. Path to an intended local directory\n    3. Extractable content\n    4. Serial title generated by [`StatuteSerialCategory.serialize()`][statute_patterns.components.category.StatuteSerialCategory.serialize]\n    5. Countability via a `collection.Counter` built-in.\n    Args:\n        cat: StatuteSerialCategory\n        id: str\n    \"\"\"\ncat: StatuteSerialCategory = Field(\n...,\ntitle=\"Statute Category\",\ndescription=\"Classification under the limited StatuteSerialCategory taxonomy.\",\n)\nid: constr(to_lower=True) = Field(  # type: ignore\n...,\ntitle=\"Serial Identifier\",\ndescription=\"Limited inclusion of identifiers, e.g. only a subset of Executive Orders, Letters of Instruction, Spanish Codes will be permitted.\",\n)\nclass Config:\nuse_enum_values = True\ndef __hash__(self):\n\"\"\"Pydantic models are [not hashable by default](https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964).\n        It is implemented here to take advantage of `collections.Counter` which works only on objects with a __hash__. This is the\n        basis of [`count_rules()`][count-rules].\"\"\"\nreturn hash((type(self),) + tuple(self.__dict__.values()))\n@validator(\"cat\", pre=True)\ndef category_in_lower_case(cls, v):\nreturn StatuteSerialCategory(v.lower())\n@validator(\"id\", pre=True)\ndef serial_id_lower(cls, v):\nreturn v.lower()\n@classmethod\ndef get_details(cls, details_path: Path):\n\"\"\"Assumes a properly structured path with three path\n        parents from details.yaml, e.g. path to `/statutes/ra/386/details.yaml`\n        means 3 parents from the same would be /statutes. Will\n        create the rule based on the details path and pull data from other\n        related paths to generate the details of the rule.\"\"\"\nfrom .details import StatuteDetails\nif rule := cls.from_path(details_path):\nstatute_path = details_path.parent.parent.parent\nreturn StatuteDetails.from_rule(rule, statute_path)\nreturn None\n@classmethod\ndef from_path(cls, details_path: Path):\n\"\"\"Construct rule from a properly structured statute's `details.yaml` file.\"\"\"\ndir = details_path.parent\ncat = dir.parent.stem\nidx = dir.stem\nif details_path.name == DETAILS_FILE:\nreturn cls(cat=StatuteSerialCategory(cat), id=idx)\nreturn None\n@property\ndef serial_title(self):\nreturn StatuteSerialCategory(self.cat).serialize(self.id)\ndef get_path(self, base_path: Path = STATUTE_PATH) -&gt; Path | None:\n\"\"\"For most cases, there only be one path to path/to/statutes/ra/386 where:\n        1. path/to/statutes = base_path\n        2. 'ra' is the category\n        3. '386' is the id.\n        \"\"\"\ntarget = base_path / self.cat / self.id\nif target.exists():\nreturn target\nreturn None\ndef get_paths(self, base_path: Path = STATUTE_PATH) -&gt; list[Path]:\n\"\"\"\n        Ordinarily, the following directory structure would suffice\n        in generating the path to a unique statute:\n        ```yaml\n        /statutes\n            /statute-category\n                /statute-serial-id\n                    details.yaml # unique details here\n        ```\n        This is not true in complex statutes.\n        To simplify, imagine Statute A, B and C have the same\n        category and identifier. But refer to different documents:\n        ```yaml\n        /statutes\n            /statute-category\n                /statute-serial-id # dated Jan. 1, 2000\n                    details.yaml # we'd need a different `statute-serial-id`\n                /statute-serial-id # dated Jan. 10, 2000\n                    details.yaml # we'd need a different `statute-serial-id`\n        ```\n        Because of this dilemma, we introduce a digit in the creation of statute\n        folders referring to more than one variant of the intended document.\n        So in the case of `/statutes/rule_am/`, let's consider `00-5-03-sc`.\n        This should be a valid statute under `self.get_path()`.\n        However, since there exists 2 variants, we need to rename the original\n        folder to contemplate 2 distinct documents:\n        ```yaml\n        /statutes\n            /rule_am\n                /00-5-03-sc-1\n                    details.yaml # unique\n                /00-5-03-sc-2\n                    details.yaml # unique\n        ```\n        Unlike `get_path()` which only retrieves one Path, all Paths will be retrieved\n        using the plural form of the function `self.get_paths()`\n        \"\"\"\ntargets = []\ntarget = base_path / self.cat\npaths = target.glob(f\"{self.id}-*/{DETAILS_FILE}\")\nfor variant_path in paths:\nif variant_path.exists():\ntargets.append(variant_path.parent)\nreturn targets\ndef extract_folders(\nself, base_path: Path = STATUTE_PATH\n) -&gt; Iterator[Path]:\n\"\"\"Using the `category` and `id` of the object,\n        get the possible folder paths.\"\"\"\nif folder := self.get_path(base_path):\nyield folder\nelse:\nif folders := self.get_paths(base_path):\nyield from folders\ndef units_path(self, statute_folder: Path) -&gt; Path | None:\n\"\"\"There are two kinds of unit files:\n        1. the preferred / customized variant with the filename convention\n            `statute-category` + `statute-serial-id` + `.yaml`, e.g. `ra386.yaml`\n        2. the one scraped which is the default in the absence of a preferred\n            variant, e.g. `units.yaml`\n        \"\"\"\npreferred = statute_folder / f\"{self.cat}{self.id}.yaml\"\nif preferred.exists():\nreturn preferred\ndefault = statute_folder / \"units.yaml\"\nif default.exists():\nreturn default\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule-functions","title":"Functions","text":""},{"location":"api-rule/#statute_patterns.components.rule.Rule.__hash__","title":"<code>__hash__()</code>","text":"<p>Pydantic models are not hashable by default. It is implemented here to take advantage of <code>collections.Counter</code> which works only on objects with a hash. This is the basis of <code>count_rules()</code>.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def __hash__(self):\n\"\"\"Pydantic models are [not hashable by default](https://github.com/pydantic/pydantic/issues/1303#issuecomment-599712964).\n    It is implemented here to take advantage of `collections.Counter` which works only on objects with a __hash__. This is the\n    basis of [`count_rules()`][count-rules].\"\"\"\nreturn hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.extract_folders","title":"<code>extract_folders(base_path=STATUTE_PATH)</code>","text":"<p>Using the <code>category</code> and <code>id</code> of the object, get the possible folder paths.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def extract_folders(\nself, base_path: Path = STATUTE_PATH\n) -&gt; Iterator[Path]:\n\"\"\"Using the `category` and `id` of the object,\n    get the possible folder paths.\"\"\"\nif folder := self.get_path(base_path):\nyield folder\nelse:\nif folders := self.get_paths(base_path):\nyield from folders\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.from_path","title":"<code>from_path(details_path)</code>  <code>classmethod</code>","text":"<p>Construct rule from a properly structured statute's <code>details.yaml</code> file.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>@classmethod\ndef from_path(cls, details_path: Path):\n\"\"\"Construct rule from a properly structured statute's `details.yaml` file.\"\"\"\ndir = details_path.parent\ncat = dir.parent.stem\nidx = dir.stem\nif details_path.name == DETAILS_FILE:\nreturn cls(cat=StatuteSerialCategory(cat), id=idx)\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.get_details","title":"<code>get_details(details_path)</code>  <code>classmethod</code>","text":"<p>Assumes a properly structured path with three path parents from details.yaml, e.g. path to <code>/statutes/ra/386/details.yaml</code> means 3 parents from the same would be /statutes. Will create the rule based on the details path and pull data from other related paths to generate the details of the rule.</p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>@classmethod\ndef get_details(cls, details_path: Path):\n\"\"\"Assumes a properly structured path with three path\n    parents from details.yaml, e.g. path to `/statutes/ra/386/details.yaml`\n    means 3 parents from the same would be /statutes. Will\n    create the rule based on the details path and pull data from other\n    related paths to generate the details of the rule.\"\"\"\nfrom .details import StatuteDetails\nif rule := cls.from_path(details_path):\nstatute_path = details_path.parent.parent.parent\nreturn StatuteDetails.from_rule(rule, statute_path)\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.get_path","title":"<code>get_path(base_path=STATUTE_PATH)</code>","text":"<p>For most cases, there only be one path to path/to/statutes/ra/386 where:</p> <ol> <li>path/to/statutes = base_path</li> <li>'ra' is the category</li> <li>'386' is the id.</li> </ol> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def get_path(self, base_path: Path = STATUTE_PATH) -&gt; Path | None:\n\"\"\"For most cases, there only be one path to path/to/statutes/ra/386 where:\n    1. path/to/statutes = base_path\n    2. 'ra' is the category\n    3. '386' is the id.\n    \"\"\"\ntarget = base_path / self.cat / self.id\nif target.exists():\nreturn target\nreturn None\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.get_paths","title":"<code>get_paths(base_path=STATUTE_PATH)</code>","text":"<p>Ordinarily, the following directory structure would suffice in generating the path to a unique statute:</p> YAML<pre><code>/statutes\n/statute-category\n/statute-serial-id\ndetails.yaml # unique details here\n</code></pre> <p>This is not true in complex statutes.</p> <p>To simplify, imagine Statute A, B and C have the same category and identifier. But refer to different documents:</p> YAML<pre><code>/statutes\n/statute-category\n/statute-serial-id # dated Jan. 1, 2000\ndetails.yaml # we'd need a different `statute-serial-id`\n/statute-serial-id # dated Jan. 10, 2000\ndetails.yaml # we'd need a different `statute-serial-id`\n</code></pre> <p>Because of this dilemma, we introduce a digit in the creation of statute folders referring to more than one variant of the intended document.</p> <p>So in the case of <code>/statutes/rule_am/</code>, let's consider <code>00-5-03-sc</code>. This should be a valid statute under <code>self.get_path()</code>.</p> <p>However, since there exists 2 variants, we need to rename the original folder to contemplate 2 distinct documents:</p> YAML<pre><code>/statutes\n/rule_am\n/00-5-03-sc-1\ndetails.yaml # unique\n/00-5-03-sc-2\ndetails.yaml # unique\n</code></pre> <p>Unlike <code>get_path()</code> which only retrieves one Path, all Paths will be retrieved using the plural form of the function <code>self.get_paths()</code></p> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def get_paths(self, base_path: Path = STATUTE_PATH) -&gt; list[Path]:\n\"\"\"\n    Ordinarily, the following directory structure would suffice\n    in generating the path to a unique statute:\n    ```yaml\n    /statutes\n        /statute-category\n            /statute-serial-id\n                details.yaml # unique details here\n    ```\n    This is not true in complex statutes.\n    To simplify, imagine Statute A, B and C have the same\n    category and identifier. But refer to different documents:\n    ```yaml\n    /statutes\n        /statute-category\n            /statute-serial-id # dated Jan. 1, 2000\n                details.yaml # we'd need a different `statute-serial-id`\n            /statute-serial-id # dated Jan. 10, 2000\n                details.yaml # we'd need a different `statute-serial-id`\n    ```\n    Because of this dilemma, we introduce a digit in the creation of statute\n    folders referring to more than one variant of the intended document.\n    So in the case of `/statutes/rule_am/`, let's consider `00-5-03-sc`.\n    This should be a valid statute under `self.get_path()`.\n    However, since there exists 2 variants, we need to rename the original\n    folder to contemplate 2 distinct documents:\n    ```yaml\n    /statutes\n        /rule_am\n            /00-5-03-sc-1\n                details.yaml # unique\n            /00-5-03-sc-2\n                details.yaml # unique\n    ```\n    Unlike `get_path()` which only retrieves one Path, all Paths will be retrieved\n    using the plural form of the function `self.get_paths()`\n    \"\"\"\ntargets = []\ntarget = base_path / self.cat\npaths = target.glob(f\"{self.id}-*/{DETAILS_FILE}\")\nfor variant_path in paths:\nif variant_path.exists():\ntargets.append(variant_path.parent)\nreturn targets\n</code></pre>"},{"location":"api-rule/#statute_patterns.components.rule.Rule.units_path","title":"<code>units_path(statute_folder)</code>","text":"<p>There are two kinds of unit files:</p> <ol> <li>the preferred / customized variant with the filename convention     <code>statute-category</code> + <code>statute-serial-id</code> + <code>.yaml</code>, e.g. <code>ra386.yaml</code></li> <li>the one scraped which is the default in the absence of a preferred     variant, e.g. <code>units.yaml</code></li> </ol> Source code in <code>statute_patterns/components/rule.py</code> Python<pre><code>def units_path(self, statute_folder: Path) -&gt; Path | None:\n\"\"\"There are two kinds of unit files:\n    1. the preferred / customized variant with the filename convention\n        `statute-category` + `statute-serial-id` + `.yaml`, e.g. `ra386.yaml`\n    2. the one scraped which is the default in the absence of a preferred\n        variant, e.g. `units.yaml`\n    \"\"\"\npreferred = statute_folder / f\"{self.cat}{self.id}.yaml\"\nif preferred.exists():\nreturn preferred\ndefault = statute_folder / \"units.yaml\"\nif default.exists():\nreturn default\nreturn None\n</code></pre>"}]}